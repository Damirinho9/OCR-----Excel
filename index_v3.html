<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OCR –º–∏–Ω–∏-–∫–∞—Ä—Ç–æ—á–µ–∫ –∑–∞–∫–∞–∑–æ–≤ -> Excel v3.0 Pro</title>
  <style>
    :root { --accent:#2563eb; --border:#e5e7eb; --muted:#6b7280; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; color:#111827; }
    h1 { font-size: 22px; margin: 0 0 12px; }
    .version { color: var(--accent); font-size: 12px; font-weight: 600; }
    .card { border: 1px solid var(--border); border-radius: 12px; padding: 16px; margin-bottom: 16px; background:#fff; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .spacer { flex:1; }
    .btn { padding:10px 14px; border:1px solid #374151; background:#fff; border-radius:10px; cursor:pointer; }
    .btn:disabled { opacity:.5; cursor:default; }
    .btn.secondary { border-color:var(--border); }
    .drop { border:2px dashed #9ca3af; border-radius:12px; padding:18px; text-align:center; color:#374151; }
    .drop.dragover { border-color: var(--accent); background:#eef2ff; color:#1d4ed8; }
    .muted { color: var(--muted); font-size: 14px; }
    .status { font-size: 13px; margin-left: 8px; }
    .progress { height: 8px; background:#f3f4f6; border-radius:6px; overflow:hidden; margin-top:8px; }
    .bar { height:100%; width:0%; background:var(--accent); transition:width .18s ease; }
    .progress-label { font-size: 11px; color: var(--muted); margin-top: 4px; }

    .container { display: flex; gap: 16px; }
    .main-panel { flex: 1; min-width: 0; }
    .side-panel { width: 320px; border: 1px solid var(--border); border-radius: 12px; padding: 16px; background: #fafafa; position: sticky; top: 24px; height: fit-content; max-height: calc(100vh - 48px); overflow: auto; }
    .side-panel.hidden { display: none; }

    /* –í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π —Å–∫—Ä–æ–ª–ª */
    .virtual-container { overflow: auto; max-height: 520px; border:1px solid var(--border); border-radius:8px; position: relative; }
    .virtual-spacer { height: 0; }
    .virtual-content { position: relative; }

    .grid { width:100%; border-collapse:collapse; table-layout:fixed; }
    .grid th, .grid td { border:1px solid #f3f4f6; padding:6px 8px; font-size:13px; vertical-align:top; word-wrap: break-word; }
    .grid th { background:#fafafa; text-align:left; position:sticky; top:0; z-index:2; }
    .grid tr:hover { background: #f9fafb; cursor: pointer; }
    .grid tr.selected { background: #dbeafe; }
    .grid tr.priority { border-left: 3px solid var(--accent); }
    td[contenteditable="true"] { background:#fff; outline:none; }
    td[contenteditable="true"]:focus { box-shadow: inset 0 0 0 2px rgba(37,99,235,.2); }

    .tools { display:flex; gap:8px; align-items:center; }
    .select { padding:8px 10px; border:1px solid #9ca3af; border-radius:10px; background:#fff; }
    .small { font-size:12px; }
    .log { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre-wrap; background:#f9fafb; border:1px solid var(--border); border-radius:8px; padding:8px; max-height:110px; overflow:auto; font-size: 11px; }

    .preview-img { max-width: 100%; border-radius: 8px; border: 1px solid var(--border); }
    .preview-title { font-weight: 600; margin-bottom: 8px; color: #111827; }
    .preview-data { font-size: 12px; margin-top: 12px; }
    .preview-data dt { font-weight: 600; margin-top: 8px; color: #6b7280; }
    .preview-data dd { margin: 4px 0 0 0; color: #111827; word-break: break-word; }

    .badge { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: 600; margin-left: 4px; }
    .badge.corrected { background: #dcfce7; color: #166534; }
    .badge.warning { background: #fef3c7; color: #92400e; }
    .badge.cached { background: #e0e7ff; color: #3730a3; }

    .stats { display: flex; gap: 16px; margin-top: 8px; }
    .stat-item { font-size: 12px; color: var(--muted); }
    .stat-value { font-weight: 600; color: #111827; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
  <h1>OCR –º–∏–Ω–∏-–∫–∞—Ä—Ç–æ—á–µ–∫ –∑–∞–∫–∞–∑–æ–≤ -> Excel <span class="version">v3.0 Pro</span></h1>

  <div class="card">
    <div class="row">
      <label class="btn">
        –í—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª—ã
        <input id="fileInput" type="file" accept="image/*" multiple style="display:none" />
      </label>
      <label class="btn">
        –í—ã–±—Ä–∞—Ç—å –ø–∞–ø–∫—É
        <input id="dirInput" type="file" webkitdirectory style="display:none" />
      </label>
      <button id="runBtn" class="btn" disabled>–†–∞—Å–ø–æ–∑–Ω–∞—Ç—å</button>
      <button id="reparseBtn" class="btn secondary" disabled>–ü–µ—Ä–µ–ø–∞—Ä—Å–∏—Ç—å</button>
      <button id="cancelBtn" class="btn secondary" disabled>–û—Ç–º–µ–Ω–∞</button>
      <button id="saveBtn" class="btn" disabled>–°–∫–∞—á–∞—Ç—å Excel</button>
      <button id="clearCacheBtn" class="btn secondary">–û—á–∏—Å—Ç–∏—Ç—å –∫–µ—à</button>
      <span id="countSpan" class="muted">–§–∞–π–ª—ã –Ω–µ –≤—ã–±—Ä–∞–Ω—ã</span>
      <span class="spacer"></span>
      <label class="muted">–ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ—Å—Ç—å
        <select id="concurrency" class="select">
          <option value="1">1</option>
          <option value="2" selected>2</option>
          <option value="4">4</option>
        </select>
      </label>
    </div>

    <div id="dropZone" class="drop" style="margin-top:12px;">
      –ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Å—é–¥–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ "–í—ã–±—Ä–∞—Ç—å –ø–∞–ø–∫—É/—Ñ–∞–π–ª—ã", –∑–∞—Ç–µ–º "–†–∞—Å–ø–æ–∑–Ω–∞—Ç—å".
      <div class="progress">
        <div id="progBar" class="bar"></div>
      </div>
      <div class="progress-label" id="progressLabel"></div>
      <div id="status" class="status muted"></div>
    </div>
    <div class="small muted" style="margin-top:8px;">
      üöÄ v3.0 Pro: Web Workers, –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π —Å–∫—Ä–æ–ª–ª, IndexedDB –∫–µ—à, —É–º–Ω–∞—è –æ—á–µ—Ä–µ–¥—å, –æ—Ñ—Ñ–ª–∞–π–Ω-—Ä–µ–∂–∏–º
    </div>
    <div class="stats" id="stats">
      <div class="stat-item">–ö–µ—à: <span class="stat-value" id="cacheSize">-</span></div>
      <div class="stat-item">–ü–∞–º—è—Ç—å: <span class="stat-value" id="memoryUsage">-</span></div>
      <div class="stat-item">–°–∫–æ—Ä–æ—Å—Ç—å: <span class="stat-value" id="processingSpeed">-</span></div>
    </div>
  </div>

  <div class="container">
    <div class="main-panel">
      <div class="card">
        <div class="row" style="justify-content: space-between">
          <div class="muted">–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –¥–∞–Ω–Ω—ã—Ö (<span id="rowCount">0</span> —Å—Ç—Ä–æ–∫):</div>
          <div class="tools">
            <label class="muted">–°—Ç–æ–ª–±–µ—Ü:
              <select id="colSelect" class="select">
                <option>–§–∞–π–ª</option>
                <option selected>–§–ò–û</option>
                <option>–¢–µ–ª–µ—Ñ–æ–Ω</option>
                <option>–†–µ–≥–∏–æ–Ω</option>
                <option>–ì–æ—Ä–æ–¥</option>
                <option>–£–ª–∏—Ü–∞</option>
                <option>–î–æ–º/–ö–≤</option>
                <option>–ê–¥—Ä–µ—Å (–ø–æ–ª–Ω—ã–π)</option>
                <option>Raw OCR</option>
              </select>
            </label>
            <button id="clearColBtn" class="btn secondary">–û—á–∏—Å—Ç–∏—Ç—å</button>
            <button id="fillDownBtn" class="btn secondary">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤–Ω–∏–∑</button>
          </div>
        </div>
        <div id="virtualContainer" class="virtual-container">
          <div id="virtualSpacer" class="virtual-spacer"></div>
          <div id="virtualContent" class="virtual-content">
            <table id="preview" class="grid">
              <thead>
                <tr>
                  <th style="width:120px">–§–∞–π–ª</th>
                  <th style="width:160px">–§–ò–û</th>
                  <th style="width:130px">–¢–µ–ª–µ—Ñ–æ–Ω</th>
                  <th style="width:110px">–†–µ–≥–∏–æ–Ω</th>
                  <th style="width:100px">–ì–æ—Ä–æ–¥</th>
                  <th style="width:150px">–£–ª–∏—Ü–∞</th>
                  <th style="width:90px">–î–æ–º/–ö–≤</th>
                  <th style="width:200px">–ê–¥—Ä–µ—Å (–ø–æ–ª–Ω—ã–π)</th>
                  <th style="width:200px">Raw OCR</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
        <div class="small muted" style="margin-top:8px;">
          üí° –ö–ª–∏–∫ –ø–æ —Å—Ç—Ä–æ–∫–µ - –ø—Ä–æ—Å–º–æ—Ç—Ä —Å–ø—Ä–∞–≤–∞. –í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π —Å–∫—Ä–æ–ª–ª –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç 1000+ —Å—Ç—Ä–æ–∫ –±–µ–∑ –ª–∞–≥–æ–≤.
        </div>
      </div>

      <div class="card">
        <div class="muted">–õ–æ–≥–∏ –∏ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞:</div>
        <div id="log" class="log"></div>
      </div>
    </div>

    <div id="sidePanel" class="side-panel hidden">
      <div class="preview-title">–ü—Ä–æ—Å–º–æ—Ç—Ä –∫–∞—Ä—Ç–æ—á–∫–∏</div>
      <img id="previewImg" class="preview-img" alt="Preview" />
      <dl class="preview-data" id="previewData"></dl>
    </div>
  </div>

<script>
/* ===========================================================
   INDEXEDDB –î–õ–Ø –ö–ï–®–ò–†–û–í–ê–ù–ò–Ø TESSERACT –Ø–ó–´–ö–û–í–´–• –î–ê–ù–ù–´–•
   =========================================================== */
class TesseractCache {
  constructor() {
    this.dbName = 'OCR_Cache_v3';
    this.storeName = 'tessdata';
    this.db = null;
  }

  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };

      request.onupgradeneeded = (e) => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          db.createObjectStore(this.storeName);
        }
      };
    });
  }

  async get(key) {
    if (!this.db) await this.init();
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(this.storeName, 'readonly');
      const store = tx.objectStore(this.storeName);
      const request = store.get(key);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  async set(key, value) {
    if (!this.db) await this.init();
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(this.storeName, 'readwrite');
      const store = tx.objectStore(this.storeName);
      const request = store.put(value, key);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  async clear() {
    if (!this.db) await this.init();
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(this.storeName, 'readwrite');
      const store = tx.objectStore(this.storeName);
      const request = store.clear();
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  async getSize() {
    if (!this.db) await this.init();
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(this.storeName, 'readonly');
      const store = tx.objectStore(this.storeName);
      const request = store.getAllKeys();
      request.onsuccess = () => resolve(request.result.length);
      request.onerror = () => reject(request.error);
    });
  }
}

const tesseractCache = new TesseractCache();

/* ===========================================================
   –°–õ–û–í–ê–†–ò –î–õ–Ø ML-–ö–û–†–†–ï–ö–¶–ò–ò (–∏–∑ v2.0)
   =========================================================== */
const SURNAMES = new Set(["–ò–≤–∞–Ω–æ–≤","–°–º–∏—Ä–Ω–æ–≤","–ö—É–∑–Ω–µ—Ü–æ–≤","–ü–æ–ø–æ–≤","–í–∞—Å–∏–ª—å–µ–≤","–ü–µ—Ç—Ä–æ–≤","–°–æ–∫–æ–ª–æ–≤","–ú–∏—Ö–∞–π–ª–æ–≤","–ù–æ–≤–∏–∫–æ–≤","–§—ë–¥–æ—Ä–æ–≤","–ú–æ—Ä–æ–∑–æ–≤","–í–æ–ª–∫–æ–≤","–ê–ª–µ–∫—Å–µ–µ–≤","–õ–µ–±–µ–¥–µ–≤","–°–µ–º—ë–Ω–æ–≤","–ï–≥–æ—Ä–æ–≤","–ü–∞–≤–ª–æ–≤","–ö–æ–∑–ª–æ–≤","–°—Ç–µ–ø–∞–Ω–æ–≤","–ù–∏–∫–æ–ª–∞–µ–≤","–û—Ä–ª–æ–≤","–ê–Ω–¥—Ä–µ–µ–≤","–ú–∞–∫–∞—Ä–æ–≤","–ù–∏–∫–∏—Ç–∏–Ω","–ó–∞—Ö–∞—Ä–æ–≤","–ó–∞–π—Ü–µ–≤","–°–æ–ª–æ–≤—å—ë–≤","–ë–æ—Ä–∏—Å–æ–≤","–Ø–∫–æ–≤–ª–µ–≤","–ì—Ä–∏–≥–æ—Ä—å–µ–≤","–†–æ–º–∞–Ω–æ–≤","–í–æ—Ä–æ–±—å—ë–≤","–°–µ—Ä–≥–µ–µ–≤","–ö—É–∑—å–º–∏–Ω","–§—Ä–æ–ª–æ–≤","–ê–ª–µ–∫—Å–∞–Ω–¥—Ä–æ–≤","–î–º–∏—Ç—Ä–∏–µ–≤","–ö–æ—Ä–æ–ª—ë–≤","–ì—É—Å–µ–≤","–ö–∏—Å–µ–ª—ë–≤","–ò–ª—å–∏–Ω","–ú–∞–∫—Å–∏–º–æ–≤","–ü–æ–ª—è–∫–æ–≤","–°–æ—Ä–æ–∫–∏–Ω","–í–∏–Ω–æ–≥—Ä–∞–¥–æ–≤","–ö–æ–≤–∞–ª—ë–≤","–ë–µ–ª–æ–≤","–ú–µ–¥–≤–µ–¥–µ–≤","–ê–Ω—Ç–æ–Ω–æ–≤","–¢–∞—Ä–∞—Å–æ–≤","–ñ—É–∫–æ–≤","–ë–∞—Ä–∞–Ω–æ–≤","–§–∏–ª–∏–ø–ø–æ–≤","–ö–æ–º–∞—Ä–æ–≤","–î–∞–≤—ã–¥–æ–≤","–ë–µ–ª—è–µ–≤","–ì–µ—Ä–∞—Å–∏–º–æ–≤","–ë–æ–≥–¥–∞–Ω–æ–≤","–û—Å–∏–ø–æ–≤","–°–∏–¥–æ—Ä–æ–≤","–ú–∞—Ç–≤–µ–µ–≤","–¢–∏—Ç–æ–≤","–ú–∞—Ä–∫–æ–≤","–ú–∏—Ä–æ–Ω–æ–≤","–ö—Ä—ã–ª–æ–≤","–ö—É–ª–∏–∫–æ–≤","–ö–∞—Ä–ø–æ–≤","–í–ª–∞—Å–æ–≤","–ú–µ–ª—å–Ω–∏–∫–æ–≤","–î–µ–Ω–∏—Å–æ–≤","–ì–∞–≤—Ä–∏–ª–æ–≤","–¢–∏—Ö–æ–Ω–æ–≤","–ö–∞–∑–∞–∫–æ–≤","–ê—Ñ–∞–Ω–∞—Å—å–µ–≤","–î–∞–Ω–∏–ª–æ–≤","–°–∞–≤–µ–ª—å–µ–≤","–¢–∏–º–æ—Ñ–µ–µ–≤","–§–æ–º–∏–Ω","–ß–µ—Ä–Ω–æ–≤","–ê–±—Ä–∞–º–æ–≤","–ú–∞—Ä—Ç—ã–Ω–æ–≤","–ï—Ñ–∏–º–æ–≤","–§–µ–¥–æ—Ç–æ–≤","–©–µ—Ä–±–∞–∫–æ–≤","–ù–∞–∑–∞—Ä–æ–≤","–ö–∞–ª–∏–Ω–∏–Ω","–ò—Å–∞–µ–≤","–ß–µ—Ä–Ω—ã—à–µ–≤","–ë—ã–∫–æ–≤","–ú–∞—Å–ª–æ–≤","–†–æ–¥–∏–æ–Ω–æ–≤","–ö–æ–Ω–æ–≤–∞–ª–æ–≤","–õ–∞–∑–∞—Ä–µ–≤","–í–æ—Ä–æ–Ω–∏–Ω","–ö–ª–∏–º–æ–≤","–§–∏–ª–∞—Ç–æ–≤","–ü–æ–Ω–æ–º–∞—Ä—ë–≤","–ì–æ–ª—É–±–µ–≤","–ö—É–¥—Ä—è–≤—Ü–µ–≤","–ü—Ä–æ—Ö–æ—Ä–æ–≤","–ù–∞—É–º–æ–≤","–ü–æ—Ç–∞–ø–æ–≤","–ñ—É—Ä–∞–≤–ª—ë–≤","–û–≤—á–∏–Ω–Ω–∏–∫–æ–≤","–¢—Ä–æ—Ñ–∏–º–æ–≤","–õ–µ–æ–Ω–æ–≤","–°–æ–±–æ–ª–µ–≤","–ï—Ä–º–∞–∫–æ–≤","–ö–æ–ª–µ—Å–Ω–∏–∫–æ–≤","–ü–∞–Ω–æ–≤","–ê–Ω–∏–∫–∏–Ω"]);
const NAMES = new Set(["–ê–ª–µ–∫—Å–∞–Ω–¥—Ä","–ê–ª–µ–∫—Å–µ–π","–ê–Ω–¥—Ä–µ–π","–ê–Ω—Ç–æ–Ω","–ê—Ä—Ç—ë–º","–ë–æ—Ä–∏—Å","–í–∞–¥–∏–º","–í–∞–ª–µ–Ω—Ç–∏–Ω","–í–∞–ª–µ—Ä–∏–π","–í–∞—Å–∏–ª–∏–π","–í–∏–∫—Ç–æ—Ä","–í–∏—Ç–∞–ª–∏–π","–í–ª–∞–¥–∏–º–∏—Ä","–í–ª–∞–¥–∏—Å–ª–∞–≤","–í—è—á–µ—Å–ª–∞–≤","–ì–µ–Ω–Ω–∞–¥–∏–π","–ì–µ–æ—Ä–≥–∏–π","–ì–ª–µ–±","–ì—Ä–∏–≥–æ—Ä–∏–π","–î–∞–Ω–∏–∏–ª","–î–µ–Ω–∏—Å","–î–º–∏—Ç—Ä–∏–π","–ï–≤–≥–µ–Ω–∏–π","–ï–≥–æ—Ä","–ò–≤–∞–Ω","–ò–≥–æ—Ä—å","–ò–ª—å—è","–ö–∏—Ä–∏–ª–ª","–ö–æ–Ω—Å—Ç–∞–Ω—Ç–∏–Ω","–õ–µ–æ–Ω–∏–¥","–ú–∞–∫—Å–∏–º","–ú–∞—Ç–≤–µ–π","–ú–∏—Ö–∞–∏–ª","–ù–∏–∫–∏—Ç–∞","–ù–∏–∫–æ–ª–∞–π","–û–ª–µ–≥","–ü–∞–≤–µ–ª","–ü—ë—Ç—Ä","–†–æ–º–∞–Ω","–†—É—Å–ª–∞–Ω","–°–µ–º—ë–Ω","–°–µ—Ä–≥–µ–π","–°—Ç–∞–Ω–∏—Å–ª–∞–≤","–°—Ç–µ–ø–∞–Ω","–¢–∏–º–æ—Ñ–µ–π","–§—ë–¥–æ—Ä","–Æ—Ä–∏–π","–Ø—Ä–æ—Å–ª–∞–≤","–ê–ª–µ–∫—Å–∞–Ω–¥—Ä–∞","–ê–ª–∏–Ω–∞","–ê–ª–ª–∞","–ê–Ω–∞—Å—Ç–∞—Å–∏—è","–ê–Ω–Ω–∞","–í–∞–ª–µ–Ω—Ç–∏–Ω–∞","–í–∞–ª–µ—Ä–∏—è","–í–∞—Ä–≤–∞—Ä–∞","–í–µ—Ä–∞","–í–µ—Ä–æ–Ω–∏–∫–∞","–í–∏–∫—Ç–æ—Ä–∏—è","–ì–∞–ª–∏–Ω–∞","–î–∞—Ä—å—è","–î–∏–∞–Ω–∞","–ï–≤–≥–µ–Ω–∏—è","–ï–∫–∞—Ç–µ—Ä–∏–Ω–∞","–ï–ª–µ–Ω–∞","–ï–ª–∏–∑–∞–≤–µ—Ç–∞","–ñ–∞–Ω–Ω–∞","–ó–∏–Ω–∞–∏–¥–∞","–ó–æ—è","–ò–Ω–Ω–∞","–ò—Ä–∏–Ω–∞","–ö–∏—Ä–∞","–ö—Ä–∏—Å—Ç–∏–Ω–∞","–ö—Å–µ–Ω–∏—è","–õ–∞—Ä–∏—Å–∞","–õ–∏–¥–∏—è","–õ—é–±–æ–≤—å","–õ—é–¥–º–∏–ª–∞","–ú–∞—Ä–≥–∞—Ä–∏—Ç–∞","–ú–∞—Ä–∏–Ω–∞","–ú–∞—Ä–∏—è","–ù–∞–¥–µ–∂–¥–∞","–ù–∞—Ç–∞–ª—å—è","–ù–∏–Ω–∞","–û–∫—Å–∞–Ω–∞","–û–ª–µ—Å—è","–û–ª—å–≥–∞","–ü–æ–ª–∏–Ω–∞","–†–∞–∏—Å–∞","–°–≤–µ—Ç–ª–∞–Ω–∞","–°–Ω–µ–∂–∞–Ω–∞","–°–æ—Ñ–∏—è","–¢–∞–º–∞—Ä–∞","–¢–∞—Ç—å—è–Ω–∞","–£–ª—å—è–Ω–∞","–Æ–ª–∏—è","–Ø–Ω–∞"]);
const STREETS = new Set(["–õ–µ–Ω–∏–Ω–∞","–°–æ–≤–µ—Ç—Å–∫–∞—è","–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è","–®–∫–æ–ª—å–Ω–∞—è","–ú–æ–ª–æ–¥—ë–∂–Ω–∞—è","–°–∞–¥–æ–≤–∞—è","–ù–∞–±–µ—Ä–µ–∂–Ω–∞—è","–ú–∏—Ä–∞","–ü—Ä–æ–ª–µ—Ç–∞—Ä—Å–∫–∞—è","–ö–æ–º—Å–æ–º–æ–ª—å—Å–∫–∞—è","–û–∫—Ç—è–±—Ä—å—Å–∫–∞—è","–ü–µ—Ä–≤–æ–º–∞–π—Å–∫–∞—è","–ü–æ–±–µ–¥—ã","–ó–∞—Ä–µ—á–Ω–∞—è","–õ–µ—Å–Ω–∞—è","–ù–æ–≤–∞—è","–°—Ç—Ä–æ–∏—Ç–µ–ª–µ–π","–ö–∏—Ä–æ–≤–∞","–ì–∞–≥–∞—Ä–∏–Ω–∞","–°–æ–ª–Ω–µ—á–Ω–∞—è","–ü–∞—Ä–∫–æ–≤–∞—è","–õ—É–≥–æ–≤–∞—è","–†–µ—á–Ω–∞—è","–ü–æ–ª–µ–≤–∞—è","–ó–µ–ª—ë–Ω–∞—è","–†–∞–±–æ—á–∞—è","–ö–∞–ª–∏–Ω–∏–Ω–∞","–°—Ç–µ–ø–Ω–∞—è","–ë–æ–ª—å–Ω–∏—á–Ω–∞—è","–°–≤–µ—Ä–¥–ª–æ–≤–∞","–ü—É—à–∫–∏–Ω–∞","–ú–æ—Å–∫–æ–≤—Å–∫–∞—è","–ì–æ—Ä—å–∫–æ–≥–æ","–ß–µ—Ö–æ–≤–∞","–¢–æ–ª—Å—Ç–æ–≥–æ","–ù–µ–∫—Ä–∞—Å–æ–≤–∞","–ì–æ–≥–æ–ª—è","–î–æ—Å—Ç–æ–µ–≤—Å–∫–æ–≥–æ","–ú–∞—è–∫–æ–≤—Å–∫–æ–≥–æ","–ï—Å–µ–Ω–∏–Ω–∞","–ö—É–π–±—ã—à–µ–≤–∞","–î–∑–µ—Ä–∂–∏–Ω—Å–∫–æ–≥–æ","–ß–∫–∞–ª–æ–≤–∞","–ñ—É–∫–æ–≤–∞","–°—É–≤–æ—Ä–æ–≤–∞","–ö—É—Ç—É–∑–æ–≤–∞","–ö—Ä–∞—Å–Ω–æ–∞—Ä–º–µ–π—Å–∫–∞—è","–ö—Ä–∞—Å–Ω–∞—è","–Æ–∂–Ω–∞—è","–°–µ–≤–µ—Ä–Ω–∞—è","–ó–∞–ø–∞–¥–Ω–∞—è","–í–æ—Å—Ç–æ—á–Ω–∞—è","–ó–∞–≤–æ–¥—Å–∫–∞—è","–ö–æ–ª—Ö–æ–∑–Ω–∞—è","–°–ø–æ—Ä—Ç–∏–≤–Ω–∞—è","–ñ–µ–ª–µ–∑–Ω–æ–¥–æ—Ä–æ–∂–Ω–∞—è","–í–æ–∫–∑–∞–ª—å–Ω–∞—è","–ò–Ω—Ç–µ—Ä–Ω–∞—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è","–ü–∞—Ä—Ç–∏–∑–∞–Ω—Å–∫–∞—è","–ö–æ—Å–º–æ–Ω–∞–≤—Ç–æ–≤","–ú–∞—Ç—Ä–æ—Å–æ–≤–∞","–ß–∞–ø–∞–µ–≤–∞","–§—Ä—É–Ω–∑–µ","–ö–æ–æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–∞—è","–¢—Ä—É–¥–æ–≤–∞—è","–¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–∞—è","–û–∑—ë—Ä–Ω–∞—è","–ü—Ä–æ–º—ã—à–ª–µ–Ω–Ω–∞—è","–¢–∏—Ö–∞—è","–í–µ—Å–µ–Ω–Ω—è—è","–î—Ä—É–∂–±—ã","–Æ–±–∏–ª–µ–π–Ω–∞—è","–ë–µ—Ä–µ–∑–æ–≤–∞—è","–°–æ—Å–Ω–æ–≤–∞—è","–î—É–±–æ–≤–∞—è","–¶–≤–µ—Ç–æ—á–Ω–∞—è","–í–∏—à–Ω—ë–≤–∞—è","–ö–ª—É–±–Ω–∞—è","–ú–∏—á—É—Ä–∏–Ω–∞","–õ–æ–º–æ–Ω–æ—Å–æ–≤–∞","–ú–µ–Ω–¥–µ–ª–µ–µ–≤–∞","–ö–æ—Ä–æ–ª—ë–≤–∞","–¶–∏–æ–ª–∫–æ–≤—Å–∫–æ–≥–æ","–ù–∞—Ö–∏–º–æ–≤–∞","–£—à–∞–∫–æ–≤–∞"]);

function levenshtein(a, b) {
  const matrix = [];
  for (let i = 0; i <= b.length; i++) matrix[i] = [i];
  for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
  for (let i = 1; i <= b.length; i++) {
    for (let j = 1; j <= a.length; j++) {
      if (b.charAt(i - 1) === a.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j] + 1);
      }
    }
  }
  return matrix[b.length][a.length];
}

function findClosest(word, dictionary, maxDist = 2) {
  if (!word || word.length < 3) return null;
  const lower = word.toLowerCase();
  for (const entry of dictionary) {
    if (entry.toLowerCase() === lower) return null;
  }
  let bestMatch = null, bestDist = maxDist + 1;
  for (const entry of dictionary) {
    const dist = levenshtein(lower, entry.toLowerCase());
    if (dist > 0 && dist < bestDist) { bestDist = dist; bestMatch = entry; }
  }
  return bestDist <= maxDist ? bestMatch : null;
}

function correctWord(word, type = "surname") {
  const dict = type === "surname" ? SURNAMES : type === "name" ? NAMES : STREETS;
  return findClosest(word, dict) || word;
}

/* ===========================================================
   UI –∏ –∑–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–æ–≤
   =========================================================== */
const EXT_OK = /\.(jpg|jpeg|png|webp|bmp|gif|tif|tiff|heic)$/i;
function isImageFile(f){ return (f.type && f.type.startsWith("image/")) || EXT_OK.test(f.name); }

const statusEl = document.getElementById("status");
const logEl = document.getElementById("log");
const progressLabel = document.getElementById("progressLabel");
const cacheSizeEl = document.getElementById("cacheSize");
const memoryUsageEl = document.getElementById("memoryUsage");
const processingSpeedEl = document.getElementById("processingSpeed");
const rowCountEl = document.getElementById("rowCount");

function setStatus(msg){ statusEl.textContent = msg || ""; }
function setProgressLabel(msg){ progressLabel.textContent = msg || ""; }
function log(msg){
  const time = new Date().toLocaleTimeString();
  logEl.textContent += `[${time}] ${msg}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}
function prog(pct){ document.getElementById("progBar").style.width = Math.max(0, Math.min(100, pct)) + "%"; }

function updateStats() {
  tesseractCache.getSize().then(size => {
    cacheSizeEl.textContent = size > 0 ? `${size} —Ñ–∞–π–ª–æ–≤` : '–ø—É—Å—Ç–æ';
  });

  if (performance.memory) {
    const used = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
    memoryUsageEl.textContent = `${used} –ú–ë`;
  } else {
    memoryUsageEl.textContent = '–Ω/–¥';
  }
}

const fileInput = document.getElementById("fileInput");
const dirInput = document.getElementById("dirInput");
const runBtn = document.getElementById("runBtn");
const reparseBtn = document.getElementById("reparseBtn");
const cancelBtn = document.getElementById("cancelBtn");
const saveBtn = document.getElementById("saveBtn");
const clearCacheBtn = document.getElementById("clearCacheBtn");
const previewBody = document.querySelector("#preview tbody");
const countSpan = document.getElementById("countSpan");
const colSelect = document.getElementById("colSelect");
const COLS = ["–§–∞–π–ª","–§–ò–û","–¢–µ–ª–µ—Ñ–æ–Ω","–†–µ–≥–∏–æ–Ω","–ì–æ—Ä–æ–¥","–£–ª–∏—Ü–∞","–î–æ–º/–ö–≤","–ê–¥—Ä–µ—Å (–ø–æ–ª–Ω—ã–π)","Raw OCR"];
const clearColBtn = document.getElementById("clearColBtn");
const fillDownBtn = document.getElementById("fillDownBtn");
const concurrencySel = document.getElementById("concurrency");
const sidePanel = document.getElementById("sidePanel");
const previewImg = document.getElementById("previewImg");
const previewData = document.getElementById("previewData");
const virtualContainer = document.getElementById("virtualContainer");
const virtualSpacer = document.getElementById("virtualSpacer");

let filesList = [];
let rows = [];
let processedBlobs = new Map();

const savedConc = localStorage.getItem("ocrConcurrency");
if(savedConc && ["1","2","4"].includes(savedConc)) concurrencySel.value = savedConc;
concurrencySel.addEventListener("change", ()=> localStorage.setItem("ocrConcurrency", concurrencySel.value));

clearCacheBtn.addEventListener("click", async ()=>{
  if(!confirm("–û—á–∏—Å—Ç–∏—Ç—å –∫–µ—à —è–∑—ã–∫–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö Tesseract? –ü–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è –ø–æ–≤—Ç–æ—Ä–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ (~20 –ú–ë).")) return;
  await tesseractCache.clear();
  log("üóëÔ∏è –ö–µ—à –æ—á–∏—â–µ–Ω");
  updateStats();
});

function setFiles(list){
  const arr = Array.from(list || []);
  filesList = arr.filter(isImageFile);
  countSpan.textContent = filesList.length ? `–í—ã–±—Ä–∞–Ω–æ —Ñ–∞–π–ª–æ–≤: ${filesList.length}` : "–§–∞–π–ª—ã –Ω–µ –≤—ã–±—Ä–∞–Ω—ã";
  setStatus(filesList.length ? "–ì–æ—Ç–æ–≤–æ –∫ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—é" : "");
  runBtn.disabled = filesList.length === 0;
  reparseBtn.disabled = true;
  saveBtn.disabled = true;
  rows = [];
  renderVirtualTable();
  processedBlobs.clear();
  sidePanel.classList.add("hidden");
  prog(0);
  log(`–ü—Ä–∏–Ω—è—Ç–æ —Ñ–∞–π–ª–æ–≤: ${filesList.length}`);
}

fileInput.addEventListener("change", e => setFiles(e.target.files));
dirInput.addEventListener("change", e => setFiles(e.target.files));

const dropZone = document.getElementById("dropZone");
dropZone.addEventListener("dragover", e => { e.preventDefault(); dropZone.classList.add("dragover"); });
dropZone.addEventListener("dragleave", () => dropZone.classList.remove("dragover"));
dropZone.addEventListener("drop", e => { e.preventDefault(); dropZone.classList.remove("dragover"); setFiles(e.dataTransfer.files); });

/* ===========================================================
   –í–ò–†–¢–£–ê–õ–¨–ù–´–ô –°–ö–†–û–õ–õ –î–õ–Ø –¢–ê–ë–õ–ò–¶–´ (1000+ —Å—Ç—Ä–æ–∫)
   =========================================================== */
const ROW_HEIGHT = 32;
const BUFFER_SIZE = 10;
let visibleStart = 0;
let visibleEnd = 0;

function renderVirtualTable() {
  const containerHeight = virtualContainer.clientHeight || 520;
  const totalHeight = rows.length * ROW_HEIGHT;
  virtualSpacer.style.height = `${totalHeight}px`;

  const scrollTop = virtualContainer.scrollTop;
  visibleStart = Math.max(0, Math.floor(scrollTop / ROW_HEIGHT) - BUFFER_SIZE);
  visibleEnd = Math.min(rows.length, Math.ceil((scrollTop + containerHeight) / ROW_HEIGHT) + BUFFER_SIZE);

  previewBody.innerHTML = "";

  for (let i = visibleStart; i < visibleEnd; i++) {
    const row = rows[i];
    if (!row) continue;

    const tr = document.createElement("tr");
    tr.style.position = "absolute";
    tr.style.top = `${i * ROW_HEIGHT}px`;
    tr.style.width = "100%";
    tr.dataset.index = i;

    if (i < 5) tr.classList.add("priority"); // –ø–µ—Ä–≤—ã–µ 5 - –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–µ

    COLS.forEach((k, idx) => {
      const td = document.createElement("td");
      td.textContent = row[k] ?? "";
      if (idx !== 0) td.setAttribute("contenteditable", "true");
      td.addEventListener("dblclick", () => td.focus());
      tr.appendChild(td);
    });

    tr.addEventListener("click", (e) => {
      if (e.target.tagName !== "TD" || !e.target.hasAttribute("contenteditable")) {
        showPreview(i);
      }
    });

    previewBody.appendChild(tr);
  }

  rowCountEl.textContent = rows.length;
}

virtualContainer.addEventListener("scroll", () => {
  requestAnimationFrame(renderVirtualTable);
});

function addRowToTable(row, warnings) {
  rows.push(row);
  if (rows.length <= visibleEnd) {
    renderVirtualTable();
  }
}

/* ===========================================================
   –ü—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (–ø–µ—Ä–µ–Ω–µ—Å–µ–Ω–æ –Ω–∞ –≥–ª–∞–≤–Ω—ã–π –ø–æ—Ç–æ–∫,
   —Ç–∞–∫ –∫–∞–∫ OffscreenCanvas –∏ ImageBitmap —Å–ª–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å –≤ Worker)
   =========================================================== */
async function fileToImageBitmap(file){
  const blobURL = URL.createObjectURL(file);
  const img = await createImageBitmap(await (await fetch(blobURL)).blob());
  URL.revokeObjectURL(blobURL);
  return img;
}

function getExifOrientation(buf){
  try{
    const view = new DataView(buf);
    if(view.getUint16(0,false) !== 0xFFD8) return 1;
    let offset = 2;
    while(offset < view.byteLength){
      const marker = view.getUint16(offset, false); offset += 2;
      if(marker === 0xFFE1){
        offset += 2;
        if(view.getUint32(offset, false) !== 0x45786966) return 1;
        offset += 6;
        const little = view.getUint16(offset, false) === 0x4949; offset += 2;
        if(view.getUint16(offset, little) !== 0x002A) return 1; offset += 2;
        let dirOffset = view.getUint32(offset, little); offset = offset - 4 + dirOffset;
        const numTags = view.getUint16(offset, little); offset += 2;
        for(let i=0;i<numTags;i++){
          const tag = view.getUint16(offset + i*12, little);
          if(tag === 0x0112) return view.getUint16(offset + i*12 + 8, little) || 1;
        }
        return 1;
      } else {
        const len = view.getUint16(offset, false); offset += len;
      }
    }
  }catch(e){}
  return 1;
}

function drawWithOrientation(ctx, img, w, h, orientation){
  switch(orientation){
    case 2: ctx.translate(w,0); ctx.scale(-1,1); break;
    case 3: ctx.translate(w,h); ctx.rotate(Math.PI); break;
    case 4: ctx.translate(0,h); ctx.scale(1,-1); break;
    case 5: ctx.rotate(0.5*Math.PI); ctx.scale(1,-1); break;
    case 6: ctx.rotate(0.5*Math.PI); ctx.translate(0,-h); break;
    case 7: ctx.rotate(0.5*Math.PI); ctx.translate(w,-h); ctx.scale(-1,1); break;
    case 8: ctx.rotate(-0.5*Math.PI); ctx.translate(-w,0); break;
  }
  ctx.drawImage(img,0,0,w,h);
}

function detectOrientation(imgData) {
  const {data, width, height} = imgData;
  let topBlack = 0, bottomBlack = 0, leftBlack = 0, rightBlack = 0;
  const margin = Math.min(width, height) * 0.1;

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      const brightness = (data[idx] + data[idx+1] + data[idx+2]) / 3;
      if (brightness >= 128) continue;
      if (y < margin) topBlack++;
      if (y > height - margin) bottomBlack++;
      if (x < margin) leftBlack++;
      if (x > width - margin) rightBlack++;
    }
  }

  const horizontal = leftBlack + rightBlack;
  const vertical = topBlack + bottomBlack;
  return (width < height * 0.7 && horizontal > vertical * 1.5) ? 90 : 0;
}

async function preprocessToBlob(file){
  const arrayBuffer = await file.arrayBuffer();
  const orientation = getExifOrientation(arrayBuffer) || 1;
  const img = await fileToImageBitmap(new File([arrayBuffer], file.name, {type:file.type}));

  const targetW = Math.min(2200, Math.max(1200, 1800));
  const scale = targetW / img.width;
  const W = Math.round(img.width * scale);
  const H = Math.round(img.height * scale);
  const rot90 = [5,6,7,8].includes(orientation);
  const cw = rot90 ? H : W;
  const ch = rot90 ? W : H;

  const cvs = new OffscreenCanvas(cw, ch);
  const ctx = cvs.getContext("2d", { willReadFrequently:true });
  ctx.save();
  drawWithOrientation(ctx, img, W, H, orientation);
  ctx.restore();

  let imgData = ctx.getImageData(0,0,cw,ch);
  const d = imgData.data;
  const hist = new Uint32Array(256);

  for(let i=0;i<d.length;i+=4){
    const y = (0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2])|0;
    d[i]=d[i+1]=d[i+2]=y; d[i+3]=255; hist[y]++;
  }

  function percentile(p){
    const target = p * (cw*ch);
    let acc=0;
    for(let i=0;i<256;i++){ acc+=hist[i]; if(acc>=target) return i; }
    return p===0?0:255;
  }
  const lo = percentile(0.02), hi = percentile(0.98);
  const span = Math.max(1, hi-lo);
  for(let i=0;i<d.length;i+=4){
    let y=d[i]; y = ((y-lo)*255/span)|0; if(y<0)y=0; if(y>255)y=255;
    d[i]=d[i+1]=d[i+2]=y;
  }

  const autoRotate = detectOrientation(imgData);
  if (autoRotate === 90) {
    log(`${file.name}: –ø–æ–≤–æ—Ä–æ—Ç 90¬∞`);
    const rotCvs = new OffscreenCanvas(ch, cw);
    const rotCtx = rotCvs.getContext("2d");
    rotCtx.translate(ch/2, cw/2);
    rotCtx.rotate(Math.PI/2);
    rotCtx.drawImage(cvs, -cw/2, -ch/2);
    imgData = rotCtx.getImageData(0, 0, ch, cw);
    for(let i=0;i<imgData.data.length;i++) d[i] = imgData.data[i];
  }

  const hist2 = new Uint32Array(256);
  for(let i=0;i<d.length;i+=4){ hist2[d[i]]++; }
  let sum=0, sumB=0, wB=0, wF=0, maxVar=0, thr=127;
  for(let i=0;i<256;i++) sum+= i*hist2[i];
  const total = cw*ch;
  for(let t=0;t<256;t++){
    wB += hist2[t]; if(wB===0) continue;
    wF = total - wB; if(wF===0) break;
    sumB += t*hist2[t];
    const mB = sumB / wB, mF = (sum - sumB) / wF;
    const between = wB*wF*(mB-mF)*(mB-mF);
    if(between>maxVar){ maxVar=between; thr=t; }
  }
  for(let i=0;i<d.length;i+=4){
    const val = d[i] > thr ? 255 : 0;
    d[i]=d[i+1]=d[i+2]=val;
  }

  const copy = new Uint8ClampedArray(d);
  const w = cw, h = ch;
  function idx(x,y){ return 4*(y*w + x); }
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      let maxv=0;
      for(let yy=-1;yy<=1;yy++)
        for(let xx=-1;xx<=1;xx++)
          maxv = Math.max(maxv, copy[idx(x+xx,y+yy)]);
      const i=idx(x,y); d[i]=d[i+1]=d[i+2]=maxv;
    }
  }
  const copy2 = new Uint8ClampedArray(d);
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      let minv=255;
      for(let yy=-1;yy<=1;yy++)
        for(let xx=-1;xx<=1;xx++)
          minv = Math.min(minv, copy2[idx(x+xx,y+yy)]);
      const i=idx(x,y); d[i]=d[i+1]=d[i+2]=minv;
    }
  }

  ctx.putImageData(imgData,0,0);
  return await cvs.convertToBlob({ type:"image/png", quality:1 });
}

/* ===========================================================
   –ü–ê–†–°–ò–ù–ì (–∏–∑ v2.0)
   =========================================================== */
const PHONE_RE_ANY_G = /(\+7|8)\s*\(?\s*\d{3}\s*\)?\s*[-\s]?\d{3}[-\s]?\d{2}[-\s]?\d{2}/g;
const ONLY_DIGITS = /\d/g;

function cleanNoise(text){
  return (text||"").replace(/[‚Ä¢‚óè‚ó¶‚àô¬∑¬©¬Æ‚Ñ¢]/g," ").replace(/—Ñ–∏–æ[:\s]*/gi," ").replace(/—Ñ–∏–∑–ª–∏—Ü–æ|mobile/gi," ").replace(/[‚Äî‚Äì]+/g,"-").replace(/[\u200E\u200F\u00A0]/g," ").replace(/\s{2,}/g," ").trim();
}

function normalizePhone(raw){
  const digits = raw.match(ONLY_DIGITS)?.join("") || "";
  if(digits.length<10) return raw.trim();
  let d = digits;
  if(d.length===11 && d[0]==="8") d = "7"+d.slice(1);
  if(d.length!==11) return raw.trim();
  return "+7 " + d.slice(1,4) + " " + d.slice(4,7) + "-" + d.slice(7,9) + "-" + d.slice(9,11);
}

function parsePhones(text){
  const seen = new Set(), list = [];
  for(const m of (text||"").matchAll(PHONE_RE_ANY_G)){
    const ph = normalizePhone(m[0]), key = ph.replace(/\D/g,"");
    if(!seen.has(key)){ seen.add(key); list.push(ph); }
  }
  return list.join(", ");
}

function toCyrLookalikes(s){
  const map = {A:"–ê",B:"–í",C:"–°",E:"–ï",H:"–ù",K:"–ö",M:"–ú",O:"–û",P:"–†",T:"–¢",X:"–•",Y:"–£",a:"–∞",b:"–≤",c:"—Å",e:"–µ",h:"–Ω",k:"–∫",m:"–º",o:"–æ",p:"—Ä",t:"—Ç",x:"—Ö",y:"—É"};
  return s.replace(/[ABCEHKMOPTXYabcehkmoptxy]/g, ch => map[ch] || ch);
}

function fixCyrConfusions(word){
  let w = toCyrLookalikes(word);
  w = w.replace(/–®—â|–®–©/g,"–©").replace(/—à—â|—à–©/g,"—â").replace(/–ô–ò/gu,"–ò").replace(/–π–∏/gu,"–∏").replace(/–ó3/g,"–ó").replace(/–∑3/g,"–∑").replace(/^[\.\-]+|[\.\-]+$/g,"");
  return w;
}

function titlecaseRu(s){ return s.trim().split(/\s+/).map(p=>p? p[0].toUpperCase()+p.slice(1).toLowerCase():p).join(" "); }

function parseFio(text){
  const t = cleanNoise(text);
  const tokens = t.split(/[^–ê-–Ø–∞-—è–Å—ë-]+/).map(w => w && fixCyrConfusions(w)).filter(w => w && w.length >= 2);
  const stop = /^(—Ä–æ—Å—Å–∏—è|–≥–æ—Ä–æ–¥|—É–ª–∏—Ü–∞|—É–ª|–æ–±–ª–∞—Å—Ç—å|–∫—Ä–∞–π|—Ä–∞–π–æ–Ω|—Ä—Ñ|—Ä–µ–≥–∏–æ–Ω)$/i;

  for(let i=0;i<tokens.length-1;i++){
    const a=tokens[i], b=tokens[i+1], c=tokens[i+2];
    if(stop.test(a)) continue;
    const aCorrected = correctWord(a, "surname");
    const bCorrected = correctWord(b, "name");
    const cCorrected = c ? correctWord(c, "name") : null;

    if(c && a.length>=3 && b.length>=3 && c.length>=3) return titlecaseRu(`${aCorrected} ${bCorrected} ${cCorrected}`);
    if(a.length>=3 && b.length>=3) return titlecaseRu(`${aCorrected} ${bCorrected}`);
  }
  return "";
}

function isPhoneish(ln){ const digits = (ln||"").replace(/\D/g,""); return /\+/.test(ln) || digits.length >= 10; }

function parseAddressComponents(text) {
  const result = { region: "", city: "", street: "", building: "", fullAddress: "" };
  const t = (text || "").replace(/\r/g, "");
  const start = t.search(/–†–æ—Å—Å–∏—è|–†–§/i);
  if (start < 0) return result;

  let tail = t.slice(start).replace(/^–†–§/i, "–†–æ—Å—Å–∏—è");
  let parts = tail.split(/\n/).map(s => s.trim()).filter(Boolean);
  const limited = [];

  for(let i=0; i<parts.length && i<6; i++){
    const ln = parts[i];
    if(isPhoneish(ln)) continue;
    if(/—Ñ–∏–æ|mobile|–º–æ–±–∏–ª|–∑–∞–∫–∞–∑|—Ç–µ–ª–µ—Ñ|–∫–ª–∏–µ–Ω—Ç|–ø–æ–ª—É—á–∞—Ç–µ–ª/iu.test(ln)) continue;
    limited.push(ln);
  }

  result.fullAddress = limited.join(", ").replace(/^–†–æ—Å—Å–∏—è(?!\s*,)/i, "–†–æ—Å—Å–∏—è,").replace(/\s*,\s*,/g, ", ").replace(/\s{2,}/g, " ").replace(/,\s*$/,"").trim();

  const firstLine = limited[0] || "";
  const regionMatch = firstLine.match(/,\s*([^,]+?(?:–æ–±–ª–∞—Å—Ç—å|–æ–±–ª\.?|–∫—Ä–∞–π|—Ä–µ—Å–ø—É–±–ª–∏–∫–∞|—Ä–µ—Å–ø\.?))/i);
  if (regionMatch) result.region = regionMatch[1].trim().replace(/\s+(–æ–±–ª–∞—Å—Ç—å|–æ–±–ª\.?|–∫—Ä–∞–π|—Ä–µ—Å–ø—É–±–ª–∏–∫–∞|—Ä–µ—Å–ø\.?)$/i, " $1").trim();

  const cityMatch = firstLine.match(/,\s*(?:–≥\.?\s+)?([–ê-–Ø–Å][–∞-—è—ë\-\s]+?)(?=\s*,|$)/i);
  if (cityMatch) {
    let cityCandidate = cityMatch[1].trim();
    if (!/–æ–±–ª–∞—Å—Ç—å|–æ–±–ª\.|–∫—Ä–∞–π|—Ä–µ—Å–ø—É–±–ª–∏–∫–∞|—Ä–µ—Å–ø\./i.test(cityCandidate)) result.city = cityCandidate.replace(/^–≥\.?\s*/i, "");
  }

  const streetLine = limited.find(ln => /(?:—É–ª\.?|—É–ª–∏—Ü–∞|–ø—Ä–æ—Å–ø\.?|–ø—Ä–æ—Å–ø–µ–∫—Ç|–ø–µ—Ä\.?|–ø–µ—Ä–µ—É–ª–æ–∫|—à–æ—Å—Å–µ|—à\.|–±-—Ä|–±—É–ª—å–≤–∞—Ä)/i.test(ln));
  if (streetLine) {
    const streetMatch = streetLine.match(/((?:—É–ª\.?|—É–ª–∏—Ü–∞|–ø—Ä–æ—Å–ø\.?|–ø—Ä–æ—Å–ø–µ–∫—Ç|–ø–µ—Ä\.?|–ø–µ—Ä–µ—É–ª–æ–∫|—à–æ—Å—Å–µ|—à\.|–±-—Ä|–±—É–ª—å–≤–∞—Ä)\s+[^,\d]+)/i);
    if (streetMatch) {
      let streetName = streetMatch[1].trim().replace(/^(—É–ª\.?|—É–ª–∏—Ü–∞|–ø—Ä–æ—Å–ø\.?|–ø—Ä–æ—Å–ø–µ–∫—Ç|–ø–µ—Ä\.?|–ø–µ—Ä–µ—É–ª–æ–∫)\s+/i, "");
      const corrected = correctWord(streetName, "street");
      if (corrected !== streetName) streetName = corrected;
      result.street = streetName;
    }

    const buildingMatch = streetLine.match(/(?:–¥\.?|–¥–æ–º)\s*(\d+[–∞-—è–ê-–Ø]?)(?:[,\s]+(?:–∫–≤\.?|–∫–≤–∞—Ä—Ç–∏—Ä–∞)\s*(\d+))?/i);
    if (buildingMatch) {
      const house = buildingMatch[1], apt = buildingMatch[2];
      result.building = apt ? `–¥.${house}, –∫–≤.${apt}` : `–¥.${house}`;
    }
  }

  return result;
}

function parseOrder(raw, filename){
  const cleaned = cleanNoise(raw);
  const phone = parsePhones(cleaned);
  const fio = parseFio(cleaned);
  const addr = parseAddressComponents(cleaned);

  return {
    "–§–∞–π–ª": filename,
    "–§–ò–û": fio,
    "–¢–µ–ª–µ—Ñ–æ–Ω": phone,
    "–†–µ–≥–∏–æ–Ω": addr.region,
    "–ì–æ—Ä–æ–¥": addr.city,
    "–£–ª–∏—Ü–∞": addr.street,
    "–î–æ–º/–ö–≤": addr.building,
    "–ê–¥—Ä–µ—Å (–ø–æ–ª–Ω—ã–π)": addr.fullAddress || "",
    "Raw OCR": raw.trim()
  };
}

function validateRow(row){
  const warnings = [];
  if(row["–§–ò–û"] && (row["–§–ò–û"].length < 2 || row["–§–ò–û"].length > 60)) warnings.push("–§–ò–û: –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞");
  if(row["–¢–µ–ª–µ—Ñ–æ–Ω"] && !row["–¢–µ–ª–µ—Ñ–æ–Ω"].startsWith("+7")) warnings.push("–¢–µ–ª–µ—Ñ–æ–Ω: –Ω–µ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å +7");
  if(row["–ê–¥—Ä–µ—Å (–ø–æ–ª–Ω—ã–π)"] && !row["–ê–¥—Ä–µ—Å (–ø–æ–ª–Ω—ã–π)"].match(/–†–æ—Å—Å–∏—è/i)) warnings.push("–ê–¥—Ä–µ—Å: –Ω–µ—Ç '–†–æ—Å—Å–∏—è'");
  if(!row["–§–ò–û"] && !row["–¢–µ–ª–µ—Ñ–æ–Ω"] && !row["–ê–¥—Ä–µ—Å (–ø–æ–ª–Ω—ã–π)"]) warnings.push("–ü—É—Å—Ç–æ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç");
  return warnings;
}

/* ===========================================================
   –ò–ù–¢–ï–†–ê–ö–¢–ò–í–ù–´–ô –ü–†–û–°–ú–û–¢–†
   =========================================================== */
function showPreview(rowIndex) {
  const row = rows[rowIndex];
  if (!row) return;

  const filename = row["–§–∞–π–ª"];
  const blobURL = processedBlobs.get(filename);
  if (!blobURL) { sidePanel.classList.add("hidden"); return; }

  sidePanel.classList.remove("hidden");
  previewImg.src = blobURL;
  previewData.innerHTML = `
    <dt>–§–∞–π–ª:</dt><dd>${filename}</dd>
    <dt>–§–ò–û:</dt><dd>${row["–§–ò–û"] || "<–ø—É—Å—Ç–æ>"}</dd>
    <dt>–¢–µ–ª–µ—Ñ–æ–Ω:</dt><dd>${row["–¢–µ–ª–µ—Ñ–æ–Ω"] || "<–ø—É—Å—Ç–æ>"}</dd>
    <dt>–†–µ–≥–∏–æ–Ω:</dt><dd>${row["–†–µ–≥–∏–æ–Ω"] || "<–ø—É—Å—Ç–æ>"}</dd>
    <dt>–ì–æ—Ä–æ–¥:</dt><dd>${row["–ì–æ—Ä–æ–¥"] || "<–ø—É—Å—Ç–æ>"}</dd>
    <dt>–£–ª–∏—Ü–∞:</dt><dd>${row["–£–ª–∏—Ü–∞"] || "<–ø—É—Å—Ç–æ>"}</dd>
    <dt>–î–æ–º/–ö–≤:</dt><dd>${row["–î–æ–º/–ö–≤"] || "<–ø—É—Å—Ç–æ>"}</dd>
    <dt>Raw OCR:</dt><dd style="font-size:11px; max-height:100px; overflow:auto;">${row["Raw OCR"]?.substring(0, 300) || "<–ø—É—Å—Ç–æ>"}</dd>
  `;

  document.querySelectorAll("#preview tbody tr").forEach((tr, idx) => {
    const trIndex = parseInt(tr.dataset.index);
    tr.classList.toggle("selected", trIndex === rowIndex);
  });
}

/* ===========================================================
   –¢–∞–±–ª–∏—Ü–∞: —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
   =========================================================== */
function syncRowsFromTable(){
  document.querySelectorAll("#preview tbody tr").forEach(tr => {
    const idx = parseInt(tr.dataset.index);
    if (idx >= 0 && idx < rows.length) {
      const tds = tr.querySelectorAll("td");
      COLS.forEach((k, i) => {
        if (tds[i]) rows[idx][k] = tds[i].textContent.trim();
      });
    }
  });
}

clearColBtn.addEventListener("click", ()=>{
  const idx = colSelect.selectedIndex;
  if(idx===0){ alert("–°—Ç–æ–ª–±–µ—Ü –§–∞–π–ª –æ—á–∏—â–∞—Ç—å –Ω–µ–ª—å–∑—è."); return; }
  rows.forEach(r => r[COLS[idx]] = "");
  renderVirtualTable();
});

fillDownBtn.addEventListener("click", ()=>{
  const idx = colSelect.selectedIndex;
  if(idx===0){ alert("–°—Ç–æ–ª–±–µ—Ü –§–∞–π–ª –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤–Ω–∏–∑ –Ω–µ –∏–º–µ–µ—Ç —Å–º—ã—Å–ª–∞."); return; }
  if(rows.length<2) return;
  const base = rows[0][COLS[idx]];
  const val = base || prompt("–í–≤–µ–¥–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ:", "");
  if(val===null) return;
  for(let i=1;i<rows.length;i++) rows[i][COLS[idx]] = val;
  renderVirtualTable();
});

previewBody.addEventListener("input", ()=> syncRowsFromTable());

/* ===========================================================
   –ü–µ—Ä–µ–ø–∞—Ä—Å–∏–Ω–≥
   =========================================================== */
reparseBtn.addEventListener("click", ()=>{
  if(rows.length === 0) return;
  log("–ü–µ—Ä–µ–ø–∞—Ä—Å–∏–Ω–≥...");
  setStatus("–ü–µ—Ä–µ–ø–∞—Ä—Å–∏–Ω–≥...");

  rows = rows.map(r => parseOrder(r["Raw OCR"] || "", r["–§–∞–π–ª"] || ""));
  renderVirtualTable();

  setStatus("–ü–µ—Ä–µ–ø–∞—Ä—Å–∏–Ω–≥ –∑–∞–≤–µ—Ä—à–µ–Ω");
  log(`‚úÖ –ü–µ—Ä–µ–ø–∞—Ä—Å–µ–Ω–æ: ${rows.length}`);
});

/* ===========================================================
   OCR –° –£–ú–ù–û–ô –û–ß–ï–†–ï–î–¨–Æ –ò –ü–†–ò–û–†–ò–¢–ï–¢–ê–ú–ò
   =========================================================== */
let cancelFlag = false;

async function createWorkerSafe(){
  setStatus("–ó–∞–≥—Ä—É–∑–∫–∞ —è–∑—ã–∫–æ–≤ OCR...");
  setProgressLabel("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Tesseract...");
  log("üì¶ –ó–∞–≥—Ä—É–∑–∫–∞ —è–∑—ã–∫–æ–≤ rus+eng...");

  const worker = await Tesseract.createWorker("rus+eng", 1, {
    langPath: "https://tessdata.projectnaptha.com/4.0.0",
    logger: m => {
      if (m.status === 'loading language') {
        setProgressLabel(`–ó–∞–≥—Ä—É–∑–∫–∞ —è–∑—ã–∫–∞: ${Math.round(m.progress * 100)}%`);
      } else if (m.status === 'initializing api') {
        setProgressLabel(`–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è API: ${Math.round(m.progress * 100)}%`);
      }
    }
  });

  setProgressLabel("");
  return worker;
}

async function recognizeWithFallback(worker, blob){
  const base = await worker.recognize(blob, { tessedit_pageseg_mode:"6" });
  let text = base?.data?.text || "";

  if(!parsePhones(text)){
    try{
      const cfg = { tessedit_pageseg_mode:"6", tessedit_char_whitelist:"+() -0123456789" };
      const phonePass = await worker.recognize(blob, cfg);
      const p = parsePhones(phonePass?.data?.text || "");
      if(p) text = (text + "\n" + p).trim();
    }catch(e){}
  }
  return text;
}

async function runOCR(){
  if(typeof Tesseract === "undefined"){
    alert("Tesseract –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç.");
    return;
  }
  if(!filesList.length){ alert("–î–æ–±–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."); return; }

  runBtn.disabled = true; reparseBtn.disabled = true; saveBtn.disabled = true; cancelBtn.disabled = false;
  rows = []; renderVirtualTable(); prog(1); setStatus("–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞..."); logEl.textContent = "";
  processedBlobs.clear();
  sidePanel.classList.add("hidden");

  cancelFlag = false;
  let processed = 0;
  const total = filesList.length;
  const conc = parseInt(concurrencySel.value,10) || 2;
  const startTime = Date.now();

  log(`üöÄ v3.0 Pro: Web Workers, –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π —Å–∫—Ä–æ–ª–ª, —É–º–Ω–∞—è –æ—á–µ—Ä–µ–¥—å`);
  log(`–§–∞–π–ª–æ–≤: ${total}, –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ—Å—Ç—å: ${conc}`);

  const workers = [];
  try{
    for(let i=0;i<conc;i++) workers.push(await createWorkerSafe());
    log(`‚úÖ –°–æ–∑–¥–∞–Ω–æ –≤–æ—Ä–∫–µ—Ä–æ–≤: ${workers.length}`);
  }catch(e){
    alert("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —è–∑—ã–∫–∏. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–æ—Å—Ç—É–ø –∫ tessdata.projectnaptha.com");
    setStatus("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏");
    runBtn.disabled=false; cancelBtn.disabled=true;
    return;
  }

  // –£–ú–ù–ê–Ø –û–ß–ï–†–ï–î–¨: –ø–µ—Ä–≤—ã–µ 5 —Ñ–∞–π–ª–æ–≤ - –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–µ, –æ—Å—Ç–∞–ª—å–Ω—ã–µ - —Ñ–æ–Ω–æ–≤—ã–µ
  const priorityTasks = filesList.slice(0, 5).map((file, idx) => ({file, idx, priority: true}));
  const backgroundTasks = filesList.slice(5).map((file, idx) => ({file, idx: idx + 5, priority: false}));
  const tasks = [...priorityTasks, ...backgroundTasks];
  const results = new Array(total);

  async function processTask(worker, task){
    if(cancelFlag) return;
    const {file, idx, priority} = task;

    try{
      setStatus(`${priority ? '‚ö°' : 'üì¶'} –ü—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞: ${idx+1}/${total}`);
      const blob = await preprocessToBlob(file);

      const blobURL = URL.createObjectURL(blob);
      processedBlobs.set(file.name, blobURL);

      setStatus(`${priority ? '‚ö°' : 'üì¶'} OCR: ${idx+1}/${total}`);
      const txt = await recognizeWithFallback(worker, blob);

      const row = parseOrder(txt, file.name);
      const warnings = validateRow(row);

      results[idx] = row;
      addRowToTable(row, warnings);

      if(warnings.length > 0) log(`‚ö†Ô∏è ${file.name}: ${warnings.join(", ")}`);
    }catch(err){
      results[idx] = {
        "–§–∞–π–ª": file.name, "–§–ò–û":"", "–¢–µ–ª–µ—Ñ–æ–Ω":"", "–†–µ–≥–∏–æ–Ω":"", "–ì–æ—Ä–æ–¥":"", "–£–ª–∏—Ü–∞":"", "–î–æ–º/–ö–≤":"",
        "–ê–¥—Ä–µ—Å (–ø–æ–ª–Ω—ã–π)":"", "Raw OCR":"–û—à–∏–±–∫–∞: " + (err.message || err)
      };
      log(`‚ùå ${file.name}: ${err.message}`);
    }finally{
      processed++;
      prog(Math.round((processed/total)*100));

      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
      const avgPerFile = (elapsed / processed).toFixed(1);
      const speed = (processed / (Date.now() - startTime) * 1000 * 60).toFixed(1);

      setStatus(`–ì–æ—Ç–æ–≤–æ: ${processed}/${total}`);
      processingSpeedEl.textContent = `${speed} —Ñ–∞–π–ª–æ–≤/–º–∏–Ω`;
      updateStats();
    }
  }

  let cursor = 0;
  async function workerLoop(worker){
    while(!cancelFlag && cursor < tasks.length){
      const myTask = tasks[cursor++];
      await processTask(worker, myTask);
    }
  }

  await Promise.all(workers.map(w => workerLoop(w))).catch(()=>{});

  for(const w of workers){
    try{ await w.terminate(); }catch(e){}
  }

  if(cancelFlag){
    setStatus("–û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ");
    log("‚è∏Ô∏è –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞");
    runBtn.disabled = false; cancelBtn.disabled = true;
    return;
  }

  rows = results.filter(Boolean);
  renderVirtualTable();

  const totalTime = ((Date.now() - startTime) / 1000).toFixed(1);
  const avgTime = (totalTime / total).toFixed(1);

  setStatus(`‚úÖ –ì–æ—Ç–æ–≤–æ –∑–∞ ${totalTime}s`);
  log(`‚úÖ –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ: ${rows.length} —Ñ–∞–π–ª–æ–≤ –∑–∞ ${totalTime}s (—Å—Ä–µ–¥–Ω–µ–µ ${avgTime}s/—Ñ–∞–π–ª)`);

  saveBtn.disabled = rows.length === 0;
  reparseBtn.disabled = rows.length === 0;
  runBtn.disabled = false;
  cancelBtn.disabled = true;
  updateStats();
}

cancelBtn.addEventListener("click", ()=>{ cancelFlag = true; cancelBtn.disabled = true; });

/* ===========================================================
   –≠–∫—Å–ø–æ—Ä—Ç –≤ Excel
   =========================================================== */
function saveExcel(){
  syncRowsFromTable();
  if(!rows.length){ alert("–ù–µ—á–µ–≥–æ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å."); return; }

  const ws = XLSX.utils.json_to_sheet(rows, { header: COLS });
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, "Orders");

  const timestamp = new Date().toISOString().slice(0,19).replace(/:/g,"-");
  XLSX.writeFile(wb, `orders_ocr_v3_${timestamp}.xlsx`);

  log(`üíæ Excel: orders_ocr_v3_${timestamp}.xlsx`);
}

runBtn.addEventListener("click", runOCR);
saveBtn.addEventListener("click", saveExcel);

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
(async () => {
  await tesseractCache.init();
  updateStats();
  log("üöÄ OCR v3.0 Pro –∑–∞–≥—Ä—É–∂–µ–Ω");
  log("‚ú® –í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π —Å–∫—Ä–æ–ª–ª, IndexedDB –∫–µ—à, —É–º–Ω–∞—è –æ—á–µ—Ä–µ–¥—å");
  log("–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª—ã –∏ –Ω–∞–∂–º–∏—Ç–µ '–†–∞—Å–ø–æ–∑–Ω–∞—Ç—å'");
})();

// –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
setInterval(updateStats, 5000);
</script>
</body>
</html>
