<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OCR мини-карточек заказов -> Excel</title>
  <style>
    :root { --accent:#2563eb; --border:#e5e7eb; --muted:#6b7280; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; color:#111827; }
    h1 { font-size: 22px; margin: 0 0 12px; }
    .card { border: 1px solid var(--border); border-radius: 12px; padding: 16px; margin-bottom: 16px; background:#fff; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .spacer { flex:1; }
    .btn { padding:10px 14px; border:1px solid #374151; background:#fff; border-radius:10px; cursor:pointer; }
    .btn:disabled { opacity:.5; cursor:default; }
    .btn.secondary { border-color:var(--border); }
    .drop { border:2px dashed #9ca3af; border-radius:12px; padding:18px; text-align:center; color:#374151; }
    .drop.dragover { border-color: var(--accent); background:#eef2ff; color:#1d4ed8; }
    .muted { color: var(--muted); font-size: 14px; }
    .status { font-size: 13px; margin-left: 8px; }
    .progress { height: 8px; background:#f3f4f6; border-radius:6px; overflow:hidden; margin-top:8px; }
    .bar { height:100%; width:0%; background:var(--accent); transition:width .18s ease; }
    .grid { width:100%; border-collapse:collapse; table-layout:fixed; }
    .grid th, .grid td { border:1px solid #f3f4f6; padding:6px 8px; font-size:13px; vertical-align:top; }
    .grid th { background:#fafafa; text-align:left; position:sticky; top:0; z-index:1; }
    td[contenteditable="true"] { background:#fff; outline:none; }
    td[contenteditable="true"]:focus { box-shadow: inset 0 0 0 2px rgba(37,99,235,.2); }
    .tools { display:flex; gap:8px; align-items:center; }
    .select { padding:8px 10px; border:1px solid #9ca3af; border-radius:10px; background:#fff; }
    .small { font-size:12px; }
    .log { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre-wrap; background:#f9fafb; border:1px solid var(--border); border-radius:8px; padding:8px; max-height:110px; overflow:auto; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
  <h1>OCR мини-карточек заказов -> Excel</h1>

  <div class="card">
    <div class="row">
      <label class="btn">
        Выбрать файлы
        <input id="fileInput" type="file" accept="image/*" multiple style="display:none" />
      </label>
      <label class="btn">
        Выбрать папку
        <input id="dirInput" type="file" webkitdirectory style="display:none" />
      </label>
      <button id="runBtn" class="btn" disabled>Распознать</button>
      <button id="cancelBtn" class="btn secondary" disabled>Отмена</button>
      <button id="saveBtn" class="btn" disabled>Скачать Excel</button>
      <span id="countSpan" class="muted">Файлы не выбраны</span>
      <span class="spacer"></span>
      <label class="muted">Параллельность
        <select id="concurrency" class="select">
          <option value="1">1</option>
          <option value="2">2</option>
        </select>
      </label>
    </div>

    <div id="dropZone" class="drop" style="margin-top:12px;">
      Перетащите сюда изображения или нажмите "Выбрать папку/файлы".
      <div class="progress"><div id="progBar" class="bar"></div></div>
      <div id="status" class="status muted"></div>
    </div>
    <div class="small muted" style="margin-top:8px;">
      Работает локально в браузере. На первый запуск нужен интернет для загрузки языка rus.
    </div>
  </div>

  <div class="card">
    <div class="row" style="justify-content: space-between">
      <div class="muted">Предпросмотр данных и правка:</div>
      <div class="tools">
        <label class="muted">Столбец:
          <select id="colSelect" class="select">
            <option>Файл</option>
            <option selected>ФИО</option>
            <option>Телефон</option>
            <option>Адрес</option>
            <option>Raw OCR</option>
          </select>

        </label>
        <button id="clearColBtn" class="btn secondary">Очистить столбец</button>
        <button id="fillDownBtn" class="btn secondary">Копировать вниз</button>
      </div>
    </div>
    <div style="overflow:auto; max-height: 320px; border:1px solid var(--border); border-radius:8px;">
      <table id="preview" class="grid">
        <thead>
          <tr>
            <th>Файл</th><th>ФИО</th><th>Телефон</th><th>Адрес</th><th>Raw OCR</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="small muted" style="margin-top:8px;">
      Подсказка: двойной клик по ячейке включает редактирование. После правок Excel сохранит текущие значения таблицы.
    </div>
  </div>

  <div class="card">
    <div class="muted">Логи и диагностика:</div>
    <div id="log" class="log"></div>
  </div>

<script>
/* ===========================================================
   UI и загрузка файлов — оставляем стабильную логику как в v3
   =========================================================== */
const EXT_OK = /\.(jpg|jpeg|png|webp|bmp|gif|tif|tiff|heic)$/i;
function isImageFile(f){
  return (f.type && f.type.startsWith("image/")) || EXT_OK.test(f.name);
}

const statusEl = document.getElementById("status");
const logEl = document.getElementById("log");
function setStatus(msg){ statusEl.textContent = msg || ""; }
function log(msg){ logEl.textContent += msg + "\n"; logEl.scrollTop = logEl.scrollHeight; }
function prog(pct){ document.getElementById("progBar").style.width = Math.max(0, Math.min(100, pct)) + "%"; }

const fileInput = document.getElementById("fileInput");
const dirInput  = document.getElementById("dirInput");
const runBtn    = document.getElementById("runBtn");
const cancelBtn = document.getElementById("cancelBtn");
const saveBtn   = document.getElementById("saveBtn");
const previewBody = document.querySelector("#preview tbody");
const countSpan = document.getElementById("countSpan");
const colSelect = document.getElementById("colSelect");
const COLS = ["Файл","ФИО","Телефон","Адрес","Raw OCR"];
const clearColBtn = document.getElementById("clearColBtn");
const fillDownBtn = document.getElementById("fillDownBtn");
const concurrencySel = document.getElementById("concurrency");
// после STREET_HINTS и titlecaseRu
const CITY_HINTS = [
  "ул\\.?", "улица", "просп\\.?", "проспект", "пер\\.?", "переул",
  "шоссе", "ш\\.", "б-р", "бульвар", "тракт", "мкр\\.?", "квартал",
  "кв-л", "проезд", "дом", "д\\.", "кв\\.", "№", "\\d+"
];
const CITY_CUT_RE = new RegExp("(?:^|[\\s,.;:()\\[\\]-])(?:" + CITY_HINTS.join("|") + ")", "i");

function cleanCityName(s){
  if(!s) return "";
  // убираем префиксы "г.", "город", а заодно рп/пгт/пос./с.
  let t = s.trim().replace(/^(г\\.?|город|рп\\.?|пгт\\.?|пос\\.?|с\\.)\\s*/i, "");
  const m = CITY_CUT_RE.exec(t);           // ищем первый уличный маркер или номер
  if(m) t = t.slice(0, m.index).trim();    // отрезаем всё после него
  t = t.split(/[|,]/)[0].trim();           // на всякий случай прибираем хвосты
  return titlecaseRu(t);
}

let filesList = [];
let rows = [];

function setFiles(list){
  const arr = Array.from(list || []);
  filesList = arr.filter(isImageFile);
  countSpan.textContent = filesList.length ? `Выбрано файлов: ${filesList.length}` : "Файлы не выбраны";
  setStatus(filesList.length ? "Готово к распознаванию" : "");
  runBtn.disabled = filesList.length === 0;
  saveBtn.disabled = true;
  rows = [];
  previewBody.innerHTML = "";
  prog(0);
  log("Принято файлов: " + filesList.length);
  if(filesList.length) runOCR(); // автозапуск
}

fileInput.addEventListener("change", e => setFiles(e.target.files));
dirInput .addEventListener("change", e => setFiles(e.target.files));

const dropZone = document.getElementById("dropZone");
dropZone.addEventListener("dragover", e => { e.preventDefault(); dropZone.classList.add("dragover"); });
dropZone.addEventListener("dragleave", () => dropZone.classList.remove("dragover"));
dropZone.addEventListener("drop", e => { e.preventDefault(); dropZone.classList.remove("dragover"); setFiles(e.dataTransfer.files); });

/* ===========================================================
   Предобработка изображения на canvas
   - EXIF-ориентация
   - ресайз до ширины ~1800
   - grayscale, контраст-stretch
   - Otsu бинаризация
   - легкая морфология (закрытие: дилатация -> эрозия)
   =========================================================== */
async function fileToImageBitmap(file){
  const blobURL = URL.createObjectURL(file);
  const img = await createImageBitmap(await (await fetch(blobURL)).blob());
  URL.revokeObjectURL(blobURL);
  return img;
}

function getExifOrientation(buf){
  // Мини-парсер EXIF для JPEG. Возвращает 1 при неудаче.
  try{
    const view = new DataView(buf);
    if(view.getUint16(0,false) !== 0xFFD8) return 1; // not JPEG
    let offset = 2;
    while(offset < view.byteLength){
      const marker = view.getUint16(offset, false); offset += 2;
      if(marker === 0xFFE1){ // APP1
        offset += 2; // length
        if(view.getUint32(offset, false) !== 0x45786966) return 1; // "Exif"
        offset += 6; // skip "Exif\0\0"
        const little = view.getUint16(offset, false) === 0x4949; offset += 2;
        if(view.getUint16(offset, little) !== 0x002A) return 1; offset += 2;
        let dirOffset = view.getUint32(offset, little); offset = offset - 4 + dirOffset;
        const numTags = view.getUint16(offset, little); offset += 2;
        for(let i=0;i<numTags;i++){
          const tag = view.getUint16(offset + i*12, little);
          if(tag === 0x0112){ // Orientation
            const val = view.getUint16(offset + i*12 + 8, little);
            return val || 1;
          }
        }
        return 1;
      } else {
        const len = view.getUint16(offset, false); offset += len;
      }
    }
  }catch(e){}
  return 1;
}

function drawWithOrientation(ctx, img, w, h, orientation){
  switch(orientation){
    case 2: ctx.translate(w,0); ctx.scale(-1,1); break;
    case 3: ctx.translate(w,h); ctx.rotate(Math.PI); break;
    case 4: ctx.translate(0,h); ctx.scale(1,-1); break;
    case 5: ctx.rotate(0.5*Math.PI); ctx.scale(1,-1); break;
    case 6: ctx.rotate(0.5*Math.PI); ctx.translate(0,-h); break;
    case 7: ctx.rotate(0.5*Math.PI); ctx.translate(w,-h); ctx.scale(-1,1); break;
    case 8: ctx.rotate(-0.5*Math.PI); ctx.translate(-w,0); break;
    default: break;
  }
  ctx.drawImage(img,0,0,w,h);
}

async function preprocessToBlob(file){
  const arrayBuffer = await file.arrayBuffer();
  const orientation = getExifOrientation(arrayBuffer) || 1;

  const img = await fileToImageBitmap(new File([arrayBuffer], file.name, {type:file.type}));
  // таргет ширина
  const targetW = Math.min(2200, Math.max(1200, 1800));
  const scale = targetW / img.width;
  const W = Math.round(img.width * scale);
  const H = Math.round(img.height * scale);

  // при поворотах канвас должен менять размер
  const rot90 = [5,6,7,8].includes(orientation);
  const cw = rot90 ? H : W;
  const ch = rot90 ? W : H;

  const cvs = new OffscreenCanvas(cw, ch);
  const ctx = cvs.getContext("2d", { willReadFrequently:true });
  ctx.save();
  drawWithOrientation(ctx, img, W, H, orientation);
  ctx.restore();

  // grayscale
  let imgData = ctx.getImageData(0,0,cw,ch);
  const d = imgData.data;
  const hist = new Uint32Array(256);
  for(let i=0;i<d.length;i+=4){
    const y = (0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2])|0;
    d[i]=d[i+1]=d[i+2]=y; d[i+3]=255; hist[y]++;
  }

  // contrast stretch: 2-й и 98-й перцентили
  function percentile(p){
    const target = p * (cw*ch);
    let acc=0;
    for(let i=0;i<256;i++){ acc+=hist[i]; if(acc>=target) return i; }
    return p===0?0:255;
  }
  const lo = percentile(0.02), hi = percentile(0.98);
  const span = Math.max(1, hi-lo);
  for(let i=0;i<d.length;i+=4){
    let y=d[i]; y = ((y-lo)*255/span)|0; if(y<0)y=0; if(y>255)y=255;
    d[i]=d[i+1]=d[i+2]=y;
  }

  // Otsu threshold
  const hist2 = new Uint32Array(256);
  for(let i=0;i<d.length;i+=4){ hist2[d[i]]++; }
  let sum=0, sumB=0, wB=0, wF=0, mB=0, mF=0, maxVar=0, thr=127;
  for(let i=0;i<256;i++) sum+= i*hist2[i];
  const total = cw*ch;
  for(let t=0;t<256;t++){
    wB += hist2[t]; if(wB===0) continue;
    wF = total - wB; if(wF===0) break;
    sumB += t*hist2[t];
    mB = sumB / wB; mF = (sum - sumB) / wF;
    const between = wB*wF*(mB-mF)*(mB-mF);
    if(between>maxVar){ maxVar=between; thr=t; }
  }
  for(let i=0;i<d.length;i+=4){
    const val = d[i] > thr ? 255 : 0;
    d[i]=d[i+1]=d[i+2]=val;
  }

  // morphology close (dilate -> erode) 3x3
  const copy = new Uint8ClampedArray(d);
  const w = cw, h = ch;
  function idx(x,y){ return 4*(y*w + x); }
  // dilate
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      let maxv=0;
      for(let yy=-1;yy<=1;yy++)
        for(let xx=-1;xx<=1;xx++)
          maxv = Math.max(maxv, copy[idx(x+xx,y+yy)]);
      const i=idx(x,y); d[i]=d[i+1]=d[i+2]=maxv;
    }
  }
  // erode
  const copy2 = new Uint8ClampedArray(d);
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      let minv=255;
      for(let yy=-1;yy<=1;yy++)
        for(let xx=-1;xx<=1;xx++)
          minv = Math.min(minv, copy2[idx(x+xx,y+yy)]);
      const i=idx(x,y); d[i]=d[i+1]=d[i+2]=minv;
    }
  }

  ctx.putImageData(imgData,0,0);
  const blob = await cvs.convertToBlob({ type:"image/png", quality:1 });
  return blob;
}

/* ===========================================================
   Парсинг полей из Raw OCR — явные функции
   =========================================================== */
const PHONE_RE_ANY_G = /(\+7|8)\s*\(?\s*\d{3}\s*\)?\s*[-\s]?\d{3}[-\s]?\d{2}[-\s]?\d{2}/g;
const ONLY_DIGITS = /\d/g;
const COUNTRY_PREFIX = /^\s*(Россия|РФ)\s*,\s*(.+)$/i;
const STREET_HINTS = ["ул", "улица", "просп", "пр-т", "проспект", "пер", "переул", "шоссе", "ш.", "б-р", "бульвар", "тракт", "мкр", "квартал", "кв-л", "проезд", "дом", "д.", "кв."];
const ADDRESS_RE = /((?:ул\.?|улица|просп\.?|проспект|пер\.?|переулок|шоссе|ш\.|б-р|бульвар|тракт|мкр\.?|квартал|кв-л|проезд)\s+[^\n,]*\d[^\n]*)/i;

function titlecaseRu(s){ return s.trim().split(/\s+/).map(p=>p? p[0].toUpperCase()+p.slice(1).toLowerCase():p).join(" "); }
function cleanNoise(text){
  return (text||"")
    .replace(/[•●◦∙·]/g," ")
    .replace(/[©®™]/g," ")
    .replace(/фио[:\s]*/gi," ")
    .replace(/физлицо/gi," ")
    .replace(/mobile/gi," ")
    .replace(/[—–]+/g,"-")
    .replace(/[\u200E\u200F\u00A0]/g," ")
    .replace(/\s{2,}/g," ")
    .trim();
}

function normalizePhone(raw){
  const digits = raw.match(ONLY_DIGITS)?.join("") || "";
  if(digits.length<10) return raw.trim();
  let d = digits;
  if(d.length===11 && d[0]==="8") d = "7"+d.slice(1);
  if(d.length!==11) return raw.trim();
  return "+7 " + d.slice(1,4) + " " + d.slice(4,7) + "-" + d.slice(7,9) + "-" + d.slice(9,11);
}

function parsePhones(text){
  const seen = new Set();
  const list = [];
  for(const m of (text||"").matchAll(PHONE_RE_ANY_G)){
    const ph = normalizePhone(m[0]);
    const key = ph.replace(/\D/g,""); // уникальность по цифрам
    if(!seen.has(key)){ seen.add(key); list.push(ph); }
  }
  return list.join(", ");
}

// Приводим путаемые латиницу→кириллицу и фикс "Шщ"→"Щ"
function toCyrLookalikes(s){
  const map = { A:"А", B:"В", C:"С", E:"Е", H:"Н", K:"К", M:"М", O:"О", P:"Р", T:"Т", X:"Х", Y:"У" };
  return s.replace(/[ABCEHKMOPTXY]/g, ch => map[ch] || ch)
          .replace(/[abcehkmop txy]/g, ch => map[ch.toUpperCase()]?.toLowerCase() || ch);
}

function fixCyrConfusions(word){
  let w = toCyrLookalikes(word);

  // "Шщ" → "Щ" (и во всех регистрах)
  w = w.replace(/Шщ|ШЩ/g, "Щ").replace(/шщ|шЩ/g, "щ");

  // иногда Tesseract даёт двойную мягкую "ЙИ" в начале/после согласной: "Йиван" → "Иван", "Кийа"→"Кия"
  w = w.replace(/ЙИ/gu, "И").replace(/йи/gu, "и");

  // подчистим лишние дефисы/точки по краям
  w = w.replace(/^[\.\-]+|[\.\-]+$/g, "");
  return w;
}

function parseFio(text){
  const t = cleanNoise(text);
  // берём кириллические токены, но сразу нормализуем
  const tokens = t.split(/[^А-Яа-яЁё-]+/)
    .map(w => w && fixCyrConfusions(w))
    .filter(w => w && w.length >= 2);

  const stop = /^(россия|город|улица|ул|область|край|район)$/i;

  for(let i=0;i<tokens.length-1;i++){
    const a=tokens[i], b=tokens[i+1], c=tokens[i+2];
    if(stop.test(a)) continue;
    if(c && a.length>=3 && b.length>=3 && c.length>=3) return titlecaseRu(a+" "+b+" "+c);
    if(a.length>=3 && b.length>=3) return titlecaseRu(a+" "+b);
  }
  return "";
}

function parseCountryRegionCity(text, lines){
  let country="", region="", city="";

  // 1) поиск "Россия, ..." в любом месте текста
  const m = (text||"").match(/(Россия|РФ)\s*,\s*([^,\n]+)\s*,\s*([^,\n]+)(?:\s*,\s*([^,\n]+))?/i);
  if(m){
    country = "Россия";
    region = m[2].trim();
    let c1 = m[3].trim();
    let c2 = (m[4]||"").trim();

    // если второй токен повторяет регион - берём третий
    let candidate = c1.toLowerCase() === region.toLowerCase() ? (c2 || c1) : c1;

    // если "город" распознан как область/край - берём следующий
    if(/(область|край|респ)/i.test(candidate) && c2) candidate = c2;

    city = cleanCityName(candidate);
    return { country, region, city };
  }

  // 2) фолбэк: старая логика, но допускаем "Россия" не только в начале
  for(const ln of (lines||[])){
    if(/россия|рф/i.test(ln)){
      country = "Россия";
      const tail = ln.replace(/^.*?(россия|рф)\s*,/i,"").trim();
      let parts = tail.split(",").map(p=>p.trim()).filter(Boolean);
      const seen=new Set(); parts=parts.filter(p=> (seen.has(p)?false:(seen.add(p),true)));
      if(parts.length>=1) region=parts[0];
      if(parts.length>=2) city=parts[1];
      if(parts.length>=1) region = parts[0];
      if(parts.length>=2) city   = cleanCityName(parts[1]);
      break;
    }
  }
  return {country, region, city};
}

function looksLikeStreet(ln){
  return /(?:ул\.?|улица|просп\.?|проспект|пер\.?|переулок|шоссе|ш\.|б-р|бульвар|тракт|мкр\.?|квартал|кв-л|проезд|дорога|пл\.?|площадь|наб\.?|набережная|аллея|пр-д|дом|д\.|корп\.?|стр\.?|кв\.|подъезд)/i.test(ln);
}

function isPhoneish(ln){
  const digits = (ln||"").replace(/\D/g,"");
  return /\+/.test(ln) || digits.length >= 10;
}

// Полный адрес: "Россия, ...", плюс 1-2 следующих строк со street/домом. Фильтруем телефоны и служебный мусор.
// Полный адрес: всё с первого "Россия"/"РФ" до конца текста.
// Чистим телефоны, "ФИО", "mobile" и лишние пробелы/запятые.
function parseFullAddress(text){
  const t = (text || "").replace(/\r/g, "");
  const start = t.search(/Россия|РФ/i);
  if (start < 0) {
    // фолбэк: если нет "Россия" - берём первую уличную строку
    const lines = t.split(/\n/).map(s=>s.trim()).filter(Boolean);
    const firstStreet = lines.find(ln => looksLikeStreet(ln) && !isPhoneish(ln));
    return (firstStreet || "").trim();
  }

  // хвост от "Россия" до конца
  let tail = t.slice(start);

  // нормализуем "РФ" -> "Россия"
  tail = tail.replace(/^РФ/i, "Россия");

  // режем на строки, выбрасываем телефоны и служебный мусор
  let parts = tail
    .split(/\n/)
    .map(s => s.trim())
    .filter(Boolean)
    .filter(s => !isPhoneish(s))
    .filter(s => !/фио|mobile|мобил|заказ|телеф/iu.test(s));

  // склеиваем в одну строку
  let full = parts.join(", ");

  // немного уборки пунктуации и пробелов
  full = full
    .replace(/^Россия(?!\s*,)/i, "Россия,") // запятая после "Россия"
    .replace(/\s*,\s*,/g, ", ")
    .replace(/\s{2,}/g, " ")
    .replace(/,\s*$/,"")
    .trim();

  return full;
}

function parseOrder(raw, filename){
  const cleaned = cleanNoise(raw);
  const lines = cleaned.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const phone = parsePhones(cleaned);
  const fio = parseFio(cleaned);
  const addr = parseFullAddress(cleaned, lines);
  return {"Файл":filename,"ФИО":fio,"Телефон":phone,"Адрес":addr||"","Raw OCR":raw.trim()};
}

/* Мини-тесты на регулярки — выводятся в консоль */
(function regexSelfTests(){
  try{
    console.assert(normalizePhone("+7 (961) 689-96-08")==="+7 961 689-96-08", "normalizePhone fail");
    console.assert(parsePhones("моб. 8 (951) 270 42 79, доп. +7 951 270-42-79")==="+7 951 270-42-79", "parsePhones dedup fail");
    console.assert(fixCyrConfusions("Шщитова")==="Щитова", "fixCyrConfusions Шщитова→Щитова");
    console.assert(parseFio("ФИО Шщитова Альбина Ивановна")==="Щитова Альбина Ивановна", "parseFio Щщитова");
  }catch(e){ /* не мешаем UI */ }
})();

/* ===========================================================
   Таблица: предпросмотр, редактирование, массовые операции
   =========================================================== */
function appendPreviewRow(r){
  const tr=document.createElement("tr");
  COLS.forEach((k,idx)=>{
    const td=document.createElement("td");
    td.textContent = r[k] ?? "";
    if(idx!==0){ td.setAttribute("contenteditable","true"); }
    td.addEventListener("dblclick", ()=> td.focus());
    tr.appendChild(td);
  });
  previewBody.appendChild(tr);
}

function syncRowsFromTable(){
  rows = Array.from(previewBody.querySelectorAll("tr")).map(tr=>{
    const tds = tr.querySelectorAll("td");
    const obj = {};
    COLS.forEach((k,i)=> obj[k] = (tds[i]?.textContent || "").trim());
    return obj;
  });
}

clearColBtn.addEventListener("click", ()=>{
  const idx = colSelect.selectedIndex;
  if(idx===0){ alert("Столбец Файл очищать нельзя."); return; }
  for(const tr of previewBody.querySelectorAll("tr")){
    const td = tr.children[idx];
    td.textContent = "";
  }
  syncRowsFromTable();
});

fillDownBtn.addEventListener("click", ()=>{
  const idx = colSelect.selectedIndex;
  if(idx===0){ alert("Столбец Файл копировать вниз не имеет смысла."); return; }
  const trs = Array.from(previewBody.querySelectorAll("tr"));
  if(trs.length<2) return;
  const base = trs[0].children[idx].textContent;
  const val = base || prompt("Введите значение, которое скопировать вниз:", "");
  if(val===null) return;
  for(let i=1;i<trs.length;i++){
    trs[i].children[idx].textContent = val;
  }
  syncRowsFromTable();
});

// Слежение за ручной правкой
previewBody.addEventListener("input", ()=> syncRowsFromTable());

/* ===========================================================
   Очередь OCR с лимитом параллельности и отменой
   =========================================================== */
let cancelFlag = false;

async function createWorkerSafe(){
  // грузим rus+eng, PSM 6
  setStatus("Загружаю языки OCR...");
  log("Загрузка языков rus+eng...");
  const worker = await Tesseract.createWorker("rus+eng", 1, {
    langPath: "https://tessdata.projectnaptha.com/4.0.0"
  });
  return worker;
}

async function recognizeWithFallback(worker, blob){
  // базовое распознавание
  const base = await worker.recognize(blob, { tessedit_pageseg_mode:"6" });
  let text = base?.data?.text || "";

  // если телефонов не нашли - второй проход с whitelist
  if(!parsePhones(text)){
    try{
      const cfg = { tessedit_pageseg_mode:"6", tessedit_char_whitelist:"+() -0123456789" };
      const phonePass = await worker.recognize(blob, cfg);
      const p = parsePhones(phonePass?.data?.text || "");
      if(p) text = (text + "\n" + p).trim();
    }catch(e){ /* не критично */ }
  }
  return text;
}

function chunkArray(arr, size){
  const res=[]; for(let i=0;i<arr.length;i+=size) res.push(arr.slice(i,i+size)); return res;
}

async function runOCR(){
  if(typeof Tesseract === "undefined" || !Tesseract.createWorker){
    alert("Не удалось загрузить движок распознавания. Проверьте интернет на первый запуск.");
    return;
  }
  if(!filesList.length){ alert("Добавьте изображения."); return; }

  runBtn.disabled = true; saveBtn.disabled = true; cancelBtn.disabled = false;
  rows = []; previewBody.innerHTML = ""; prog(1); setStatus("Подготовка..."); logEl.textContent = "";

  cancelFlag = false;
  let processed = 0;
  const total = filesList.length;
  const conc = parseInt(concurrencySel.value,10) || 1;

  // Пакетная обработка — создаем по воркеру на поток
  const workers = [];
  try{
    const needWorkers = conc;
    for(let i=0;i<needWorkers;i++){ workers.push(await createWorkerSafe()); }
  }catch(e){
    alert("Языковые данные не загрузились. Нужен доступ к tessdata.projectnaptha.com или VPN.");
    setStatus("Ошибка загрузки языков"); runBtn.disabled=false; cancelBtn.disabled=true; return;
  }

  // очередь
  const tasks = filesList.map((file, idx)=>({file, idx}));
  const results = new Array(tasks.length);

  async function processTask(worker, task){
    if(cancelFlag) return;
    const {file, idx} = task;
    try{
      setStatus(`Предобработка: ${idx+1} из ${total}`);
      const blob = await preprocessToBlob(file);
      setStatus(`Распознаю ${idx+1} из ${total}`);
      const txt = await recognizeWithFallback(worker, blob);
      const row = parseOrder(txt, file.name);
      results[idx] = row;
      if(previewBody.children.length < 40) appendPreviewRow(row);
    }catch(err){
      results[idx] = {"Файл": file.name, "ФИО":"", "Телефон":"", "Адрес":"", "Raw OCR":"Ошибка OCR: " + (err.message || err)};
      log(`Ошибка файла ${file.name}: ${err.message || err}`);
    }finally{
      processed++;
      prog(Math.round((processed/total)*100));
      setStatus(`Готово: ${processed} из ${total}`);
    }
  }

  // диспетчер с ограничением параллельности
  let cursor = 0;
  async function workerLoop(worker){
    while(!cancelFlag && cursor < tasks.length){
      const myTask = tasks[cursor++]; await processTask(worker, myTask);
    }
  }

  await Promise.all(workers.map(w => workerLoop(w))).catch(()=>{});
  for(const w of workers){ try{ await w.terminate(); }catch(e){} }

  if(cancelFlag){
    setStatus("Остановлено пользователем");
    log("Обработка остановлена. Можно перезапустить.");
    runBtn.disabled = false; cancelBtn.disabled = true;
    return;
  }

  rows = results.filter(Boolean);
  setStatus("Готово"); log(`Итого строк: ${rows.length}`);
  saveBtn.disabled = rows.length === 0;
  runBtn.disabled = false; cancelBtn.disabled = true;
}

cancelBtn.addEventListener("click", ()=>{ cancelFlag = true; cancelBtn.disabled = true; });

/* ===========================================================
   Экспорт в Excel
   =========================================================== */
function saveExcel(){
  syncRowsFromTable();
  if(!rows.length){ alert("Пока нечего сохранять."); return; }
  const header = COLS;
  const ws = XLSX.utils.json_to_sheet(rows, { header });
  const wb = XLSX.utils.book_new(); XLSX.utils.book_append_sheet(wb, ws, "Orders");
  XLSX.writeFile(wb, "orders_ocr.xlsx");
}
runBtn.addEventListener("click", runOCR);
saveBtn.addEventListener("click", saveExcel);
</script>
</body>
</html>