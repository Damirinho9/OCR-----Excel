<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OCR –º–∏–Ω–∏-–∫–∞—Ä—Ç–æ—á–µ–∫ –∑–∞–∫–∞–∑–æ–≤ -> Excel v2.0</title>
  <style>
    :root { --accent:#2563eb; --border:#e5e7eb; --muted:#6b7280; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; color:#111827; }
    h1 { font-size: 22px; margin: 0 0 12px; }
    .version { color: var(--accent); font-size: 12px; font-weight: 600; }
    .card { border: 1px solid var(--border); border-radius: 12px; padding: 16px; margin-bottom: 16px; background:#fff; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .spacer { flex:1; }
    .btn { padding:10px 14px; border:1px solid #374151; background:#fff; border-radius:10px; cursor:pointer; }
    .btn:disabled { opacity:.5; cursor:default; }
    .btn.secondary { border-color:var(--border); }
    .drop { border:2px dashed #9ca3af; border-radius:12px; padding:18px; text-align:center; color:#374151; }
    .drop.dragover { border-color: var(--accent); background:#eef2ff; color:#1d4ed8; }
    .muted { color: var(--muted); font-size: 14px; }
    .status { font-size: 13px; margin-left: 8px; }
    .progress { height: 8px; background:#f3f4f6; border-radius:6px; overflow:hidden; margin-top:8px; }
    .bar { height:100%; width:0%; background:var(--accent); transition:width .18s ease; }

    .container { display: flex; gap: 16px; }
    .main-panel { flex: 1; min-width: 0; }
    .side-panel { width: 320px; border: 1px solid var(--border); border-radius: 12px; padding: 16px; background: #fafafa; position: sticky; top: 24px; height: fit-content; max-height: calc(100vh - 48px); overflow: auto; }
    .side-panel.hidden { display: none; }

    .grid { width:100%; border-collapse:collapse; table-layout:fixed; }
    .grid th, .grid td { border:1px solid #f3f4f6; padding:6px 8px; font-size:13px; vertical-align:top; word-wrap: break-word; }
    .grid th { background:#fafafa; text-align:left; position:sticky; top:0; z-index:1; }
    .grid tr:hover { background: #f9fafb; cursor: pointer; }
    .grid tr.selected { background: #dbeafe; }
    td[contenteditable="true"] { background:#fff; outline:none; }
    td[contenteditable="true"]:focus { box-shadow: inset 0 0 0 2px rgba(37,99,235,.2); }

    .tools { display:flex; gap:8px; align-items:center; }
    .select { padding:8px 10px; border:1px solid #9ca3af; border-radius:10px; background:#fff; }
    .small { font-size:12px; }
    .log { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre-wrap; background:#f9fafb; border:1px solid var(--border); border-radius:8px; padding:8px; max-height:110px; overflow:auto; }

    .preview-img { max-width: 100%; border-radius: 8px; border: 1px solid var(--border); }
    .preview-title { font-weight: 600; margin-bottom: 8px; color: #111827; }
    .preview-data { font-size: 12px; margin-top: 12px; }
    .preview-data dt { font-weight: 600; margin-top: 8px; color: #6b7280; }
    .preview-data dd { margin: 4px 0 0 0; color: #111827; word-break: break-word; }

    .badge { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: 600; }
    .badge.corrected { background: #dcfce7; color: #166534; }
    .badge.warning { background: #fef3c7; color: #92400e; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.1.0/dist/tesseract.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
  <h1>OCR –º–∏–Ω–∏-–∫–∞—Ä—Ç–æ—á–µ–∫ –∑–∞–∫–∞–∑–æ–≤ -> Excel <span class="version">v2.0 Smart</span></h1>

  <div class="card">
    <div class="row">
      <label class="btn">
        –í—ã–±—Ä–∞—Ç—å —Ñ–∞–π–ª—ã
        <input id="fileInput" type="file" accept="image/*" multiple style="display:none" />
      </label>
      <label class="btn">
        –í—ã–±—Ä–∞—Ç—å –ø–∞–ø–∫—É
        <input id="dirInput" type="file" webkitdirectory style="display:none" />
      </label>
      <button id="runBtn" class="btn" disabled>–†–∞—Å–ø–æ–∑–Ω–∞—Ç—å</button>
      <button id="reparseBtn" class="btn secondary" disabled>–ü–µ—Ä–µ–ø–∞—Ä—Å–∏—Ç—å</button>
      <button id="cancelBtn" class="btn secondary" disabled>–û—Ç–º–µ–Ω–∞</button>
      <button id="saveBtn" class="btn" disabled>–°–∫–∞—á–∞—Ç—å Excel</button>
      <span id="countSpan" class="muted">–§–∞–π–ª—ã –Ω–µ –≤—ã–±—Ä–∞–Ω—ã</span>
      <span class="spacer"></span>
      <label class="muted">–ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ—Å—Ç—å
        <select id="concurrency" class="select">
          <option value="1">1</option>
          <option value="2" selected>2</option>
        </select>
      </label>
    </div>

    <div id="dropZone" class="drop" style="margin-top:12px;">
      –ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Å—é–¥–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ "–í—ã–±—Ä–∞—Ç—å –ø–∞–ø–∫—É/—Ñ–∞–π–ª—ã", –∑–∞—Ç–µ–º "–†–∞—Å–ø–æ–∑–Ω–∞—Ç—å".
      <div class="progress"><div id="progBar" class="bar"></div></div>
      <div id="status" class="status muted"></div>
    </div>
    <div class="small muted" style="margin-top:8px;">
      ‚ú® v2.0: —É–º–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥ –∞–¥—Ä–µ—Å–æ–≤, –∞–≤—Ç–æ-–∫–æ—Ä—Ä–µ–∫—Ü–∏—è –§–ò–û/—É–ª–∏—Ü, –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏, –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –ø—Ä–æ—Å–º–æ—Ç—Ä
    </div>
  </div>

  <div class="container">
    <div class="main-panel">
      <div class="card">
        <div class="row" style="justify-content: space-between">
          <div class="muted">–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –¥–∞–Ω–Ω—ã—Ö –∏ –ø—Ä–∞–≤–∫–∞:</div>
          <div class="tools">
            <label class="muted">–°—Ç–æ–ª–±–µ—Ü:
              <select id="colSelect" class="select">
                <option>–§–∞–π–ª</option>
                <option selected>–§–ò–û</option>
                <option>–¢–µ–ª–µ—Ñ–æ–Ω</option>
                <option>–†–µ–≥–∏–æ–Ω</option>
                <option>–ì–æ—Ä–æ–¥</option>
                <option>–£–ª–∏—Ü–∞</option>
                <option>–î–æ–º/–ö–≤</option>
                <option>–ê–¥—Ä–µ—Å (–ø–æ–ª–Ω—ã–π)</option>
                <option>Raw OCR</option>
              </select>
            </label>
            <button id="clearColBtn" class="btn secondary">–û—á–∏—Å—Ç–∏—Ç—å</button>
            <button id="fillDownBtn" class="btn secondary">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤–Ω–∏–∑</button>
          </div>
        </div>
        <div style="overflow:auto; max-height: 520px; border:1px solid var(--border); border-radius:8px;">
          <table id="preview" class="grid">
            <thead>
              <tr>
                <th style="width:120px">–§–∞–π–ª</th>
                <th style="width:160px">–§–ò–û</th>
                <th style="width:130px">–¢–µ–ª–µ—Ñ–æ–Ω</th>
                <th style="width:110px">–†–µ–≥–∏–æ–Ω</th>
                <th style="width:100px">–ì–æ—Ä–æ–¥</th>
                <th style="width:150px">–£–ª–∏—Ü–∞</th>
                <th style="width:90px">–î–æ–º/–ö–≤</th>
                <th style="width:200px">–ê–¥—Ä–µ—Å (–ø–æ–ª–Ω—ã–π)</th>
                <th style="width:200px">Raw OCR</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        <div class="small muted" style="margin-top:8px;">
          üí° –ö–ª–∏–∫ –ø–æ —Å—Ç—Ä–æ–∫–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–ø—Ä–∞–≤–∞. –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –ø–æ —è—á–µ–π–∫–µ - —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ.
        </div>
      </div>

      <div class="card">
        <div class="muted">–õ–æ–≥–∏ –∏ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞:</div>
        <div id="log" class="log"></div>
      </div>
    </div>

    <div id="sidePanel" class="side-panel hidden">
      <div class="preview-title">–ü—Ä–æ—Å–º–æ—Ç—Ä –∫–∞—Ä—Ç–æ—á–∫–∏</div>
      <img id="previewImg" class="preview-img" alt="Preview" />
      <dl class="preview-data" id="previewData"></dl>
    </div>
  </div>

<script>
/* ===========================================================
   –°–õ–û–í–ê–†–ò –î–õ–Ø ML-–ö–û–†–†–ï–ö–¶–ò–ò OCR
   =========================================================== */
// –¢–æ–ø-500 —Ä—É—Å—Å–∫–∏—Ö —Ñ–∞–º–∏–ª–∏–π (–∫–æ–º–ø–∞–∫—Ç–Ω–∞—è –≤–µ—Ä—Å–∏—è - —Ç–æ–ø-200 –¥–ª—è —Ä–∞–∑–º–µ—Ä–∞ —Ñ–∞–π–ª–∞)
const SURNAMES = new Set([
  "–ò–≤–∞–Ω–æ–≤","–°–º–∏—Ä–Ω–æ–≤","–ö—É–∑–Ω–µ—Ü–æ–≤","–ü–æ–ø–æ–≤","–í–∞—Å–∏–ª—å–µ–≤","–ü–µ—Ç—Ä–æ–≤","–°–æ–∫–æ–ª–æ–≤","–ú–∏—Ö–∞–π–ª–æ–≤","–ù–æ–≤–∏–∫–æ–≤","–§—ë–¥–æ—Ä–æ–≤","–ú–æ—Ä–æ–∑–æ–≤","–í–æ–ª–∫–æ–≤","–ê–ª–µ–∫—Å–µ–µ–≤","–õ–µ–±–µ–¥–µ–≤","–°–µ–º—ë–Ω–æ–≤","–ï–≥–æ—Ä–æ–≤","–ü–∞–≤–ª–æ–≤","–ö–æ–∑–ª–æ–≤","–°—Ç–µ–ø–∞–Ω–æ–≤","–ù–∏–∫–æ–ª–∞–µ–≤","–û—Ä–ª–æ–≤","–ê–Ω–¥—Ä–µ–µ–≤","–ú–∞–∫–∞—Ä–æ–≤","–ù–∏–∫–∏—Ç–∏–Ω","–ó–∞—Ö–∞—Ä–æ–≤","–ó–∞–π—Ü–µ–≤","–°–æ–ª–æ–≤—å—ë–≤","–ë–æ—Ä–∏—Å–æ–≤","–Ø–∫–æ–≤–ª–µ–≤","–ì—Ä–∏–≥–æ—Ä—å–µ–≤","–†–æ–º–∞–Ω–æ–≤","–í–æ—Ä–æ–±—å—ë–≤","–°–µ—Ä–≥–µ–µ–≤","–ö—É–∑—å–º–∏–Ω","–§—Ä–æ–ª–æ–≤","–ê–ª–µ–∫—Å–∞–Ω–¥—Ä–æ–≤","–î–º–∏—Ç—Ä–∏–µ–≤","–ö–æ—Ä–æ–ª—ë–≤","–ì—É—Å–µ–≤","–ö–∏—Å–µ–ª—ë–≤","–ò–ª—å–∏–Ω","–ú–∞–∫—Å–∏–º–æ–≤","–ü–æ–ª—è–∫–æ–≤","–°–æ—Ä–æ–∫–∏–Ω","–í–∏–Ω–æ–≥—Ä–∞–¥–æ–≤","–ö–æ–≤–∞–ª—ë–≤","–ë–µ–ª–æ–≤","–ú–µ–¥–≤–µ–¥–µ–≤","–ê–Ω—Ç–æ–Ω–æ–≤","–¢–∞—Ä–∞—Å–æ–≤","–ñ—É–∫–æ–≤","–ë–∞—Ä–∞–Ω–æ–≤","–§–∏–ª–∏–ø–ø–æ–≤","–ö–æ–º–∞—Ä–æ–≤","–î–∞–≤—ã–¥–æ–≤","–ë–µ–ª—è–µ–≤","–ì–µ—Ä–∞—Å–∏–º–æ–≤","–ë–æ–≥–¥–∞–Ω–æ–≤","–û—Å–∏–ø–æ–≤","–°–∏–¥–æ—Ä–æ–≤","–ú–∞—Ç–≤–µ–µ–≤","–¢–∏—Ç–æ–≤","–ú–∞—Ä–∫–æ–≤","–ú–∏—Ä–æ–Ω–æ–≤","–ö—Ä—ã–ª–æ–≤","–ö—É–ª–∏–∫–æ–≤","–ö–∞—Ä–ø–æ–≤","–í–ª–∞—Å–æ–≤","–ú–µ–ª—å–Ω–∏–∫–æ–≤","–î–µ–Ω–∏—Å–æ–≤","–ì–∞–≤—Ä–∏–ª–æ–≤","–¢–∏—Ö–æ–Ω–æ–≤","–ö–∞–∑–∞–∫–æ–≤","–ê—Ñ–∞–Ω–∞—Å—å–µ–≤","–î–∞–Ω–∏–ª–æ–≤","–°–∞–≤–µ–ª—å–µ–≤","–¢–∏–º–æ—Ñ–µ–µ–≤","–§–æ–º–∏–Ω","–ß–µ—Ä–Ω–æ–≤","–ê–±—Ä–∞–º–æ–≤","–ú–∞—Ä—Ç—ã–Ω–æ–≤","–ï—Ñ–∏–º–æ–≤","–§–µ–¥–æ—Ç–æ–≤","–©–µ—Ä–±–∞–∫–æ–≤","–ù–∞–∑–∞—Ä–æ–≤","–ö–∞–ª–∏–Ω–∏–Ω","–ò—Å–∞–µ–≤","–ß–µ—Ä–Ω—ã—à–µ–≤","–ë—ã–∫–æ–≤","–ú–∞—Å–ª–æ–≤","–†–æ–¥–∏–æ–Ω–æ–≤","–ö–æ–Ω–æ–≤–∞–ª–æ–≤","–õ–∞–∑–∞—Ä–µ–≤","–í–æ—Ä–æ–Ω–∏–Ω","–ö–ª–∏–º–æ–≤","–§–∏–ª–∞—Ç–æ–≤","–ü–æ–Ω–æ–º–∞—Ä—ë–≤","–ì–æ–ª—É–±–µ–≤","–ö—É–¥—Ä—è–≤—Ü–µ–≤","–ü—Ä–æ—Ö–æ—Ä–æ–≤","–ù–∞—É–º–æ–≤","–ü–æ—Ç–∞–ø–æ–≤","–ñ—É—Ä–∞–≤–ª—ë–≤","–û–≤—á–∏–Ω–Ω–∏–∫–æ–≤","–¢—Ä–æ—Ñ–∏–º–æ–≤","–õ–µ–æ–Ω–æ–≤","–°–æ–±–æ–ª–µ–≤","–ï—Ä–º–∞–∫–æ–≤","–ö–æ–ª–µ—Å–Ω–∏–∫–æ–≤","–ü–∞–Ω–æ–≤","–ê–Ω–∏–∫–∏–Ω"
]);

// –¢–æ–ø-200 —Ä—É—Å—Å–∫–∏—Ö –∏–º—ë–Ω (–º—É–∂—Å–∫–∏–µ + –∂–µ–Ω—Å–∫–∏–µ)
const NAMES = new Set([
  "–ê–ª–µ–∫—Å–∞–Ω–¥—Ä","–ê–ª–µ–∫—Å–µ–π","–ê–Ω–¥—Ä–µ–π","–ê–Ω—Ç–æ–Ω","–ê—Ä—Ç—ë–º","–ë–æ—Ä–∏—Å","–í–∞–¥–∏–º","–í–∞–ª–µ–Ω—Ç–∏–Ω","–í–∞–ª–µ—Ä–∏–π","–í–∞—Å–∏–ª–∏–π","–í–∏–∫—Ç–æ—Ä","–í–∏—Ç–∞–ª–∏–π","–í–ª–∞–¥–∏–º–∏—Ä","–í–ª–∞–¥–∏—Å–ª–∞–≤","–í—è—á–µ—Å–ª–∞–≤","–ì–µ–Ω–Ω–∞–¥–∏–π","–ì–µ–æ—Ä–≥–∏–π","–ì–ª–µ–±","–ì—Ä–∏–≥–æ—Ä–∏–π","–î–∞–Ω–∏–∏–ª","–î–µ–Ω–∏—Å","–î–º–∏—Ç—Ä–∏–π","–ï–≤–≥–µ–Ω–∏–π","–ï–≥–æ—Ä","–ò–≤–∞–Ω","–ò–≥–æ—Ä—å","–ò–ª—å—è","–ö–∏—Ä–∏–ª–ª","–ö–æ–Ω—Å—Ç–∞–Ω—Ç–∏–Ω","–õ–µ–æ–Ω–∏–¥","–ú–∞–∫—Å–∏–º","–ú–∞—Ç–≤–µ–π","–ú–∏—Ö–∞–∏–ª","–ù–∏–∫–∏—Ç–∞","–ù–∏–∫–æ–ª–∞–π","–û–ª–µ–≥","–ü–∞–≤–µ–ª","–ü—ë—Ç—Ä","–†–æ–º–∞–Ω","–†—É—Å–ª–∞–Ω","–°–µ–º—ë–Ω","–°–µ—Ä–≥–µ–π","–°—Ç–∞–Ω–∏—Å–ª–∞–≤","–°—Ç–µ–ø–∞–Ω","–¢–∏–º–æ—Ñ–µ–π","–§—ë–¥–æ—Ä","–Æ—Ä–∏–π","–Ø—Ä–æ—Å–ª–∞–≤",
  "–ê–ª–µ–∫—Å–∞–Ω–¥—Ä–∞","–ê–ª–∏–Ω–∞","–ê–ª–ª–∞","–ê–Ω–∞—Å—Ç–∞—Å–∏—è","–ê–Ω–Ω–∞","–í–∞–ª–µ–Ω—Ç–∏–Ω–∞","–í–∞–ª–µ—Ä–∏—è","–í–∞—Ä–≤–∞—Ä–∞","–í–µ—Ä–∞","–í–µ—Ä–æ–Ω–∏–∫–∞","–í–∏–∫—Ç–æ—Ä–∏—è","–ì–∞–ª–∏–Ω–∞","–î–∞—Ä—å—è","–î–∏–∞–Ω–∞","–ï–≤–≥–µ–Ω–∏—è","–ï–∫–∞—Ç–µ—Ä–∏–Ω–∞","–ï–ª–µ–Ω–∞","–ï–ª–∏–∑–∞–≤–µ—Ç–∞","–ñ–∞–Ω–Ω–∞","–ó–∏–Ω–∞–∏–¥–∞","–ó–æ—è","–ò–Ω–Ω–∞","–ò—Ä–∏–Ω–∞","–ö–∏—Ä–∞","–ö—Ä–∏—Å—Ç–∏–Ω–∞","–ö—Å–µ–Ω–∏—è","–õ–∞—Ä–∏—Å–∞","–õ–∏–¥–∏—è","–õ—é–±–æ–≤—å","–õ—é–¥–º–∏–ª–∞","–ú–∞—Ä–≥–∞—Ä–∏—Ç–∞","–ú–∞—Ä–∏–Ω–∞","–ú–∞—Ä–∏—è","–ù–∞–¥–µ–∂–¥–∞","–ù–∞—Ç–∞–ª—å—è","–ù–∏–Ω–∞","–û–∫—Å–∞–Ω–∞","–û–ª–µ—Å—è","–û–ª—å–≥–∞","–ü–æ–ª–∏–Ω–∞","–†–∞–∏—Å–∞","–°–≤–µ—Ç–ª–∞–Ω–∞","–°–Ω–µ–∂–∞–Ω–∞","–°–æ—Ñ–∏—è","–¢–∞–º–∞—Ä–∞","–¢–∞—Ç—å—è–Ω–∞","–£–ª—å—è–Ω–∞","–Æ–ª–∏—è","–Ø–Ω–∞"
]);

// –¢–æ–ø-100 –Ω–∞–∑–≤–∞–Ω–∏–π —É–ª–∏—Ü –≤ –†–æ—Å—Å–∏–∏
const STREETS = new Set([
  "–õ–µ–Ω–∏–Ω–∞","–°–æ–≤–µ—Ç—Å–∫–∞—è","–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è","–®–∫–æ–ª—å–Ω–∞—è","–ú–æ–ª–æ–¥—ë–∂–Ω–∞—è","–°–∞–¥–æ–≤–∞—è","–ù–∞–±–µ—Ä–µ–∂–Ω–∞—è","–ú–∏—Ä–∞","–ü—Ä–æ–ª–µ—Ç–∞—Ä—Å–∫–∞—è","–ö–æ–º—Å–æ–º–æ–ª—å—Å–∫–∞—è","–û–∫—Ç—è–±—Ä—å—Å–∫–∞—è","–ü–µ—Ä–≤–æ–º–∞–π—Å–∫–∞—è","–ü–æ–±–µ–¥—ã","–ó–∞—Ä–µ—á–Ω–∞—è","–õ–µ—Å–Ω–∞—è","–ù–æ–≤–∞—è","–°—Ç—Ä–æ–∏—Ç–µ–ª–µ–π","–ö–∏—Ä–æ–≤–∞","–ì–∞–≥–∞—Ä–∏–Ω–∞","–°–æ–ª–Ω–µ—á–Ω–∞—è","–ü–∞—Ä–∫–æ–≤–∞—è","–õ—É–≥–æ–≤–∞—è","–†–µ—á–Ω–∞—è","–ü–æ–ª–µ–≤–∞—è","–ó–µ–ª—ë–Ω–∞—è","–†–∞–±–æ—á–∞—è","–ö–∞–ª–∏–Ω–∏–Ω–∞","–°—Ç–µ–ø–Ω–∞—è","–ë–æ–ª—å–Ω–∏—á–Ω–∞—è","–°–≤–µ—Ä–¥–ª–æ–≤–∞","–ü—É—à–∫–∏–Ω–∞","–ú–æ—Å–∫–æ–≤—Å–∫–∞—è","–ì–æ—Ä—å–∫–æ–≥–æ","–ß–µ—Ö–æ–≤–∞","–¢–æ–ª—Å—Ç–æ–≥–æ","–ù–µ–∫—Ä–∞—Å–æ–≤–∞","–ì–æ–≥–æ–ª—è","–î–æ—Å—Ç–æ–µ–≤—Å–∫–æ–≥–æ","–ú–∞—è–∫–æ–≤—Å–∫–æ–≥–æ","–ï—Å–µ–Ω–∏–Ω–∞","–ö—É–π–±—ã—à–µ–≤–∞","–î–∑–µ—Ä–∂–∏–Ω—Å–∫–æ–≥–æ","–ß–∫–∞–ª–æ–≤–∞","–ñ—É–∫–æ–≤–∞","–°—É–≤–æ—Ä–æ–≤–∞","–ö—É—Ç—É–∑–æ–≤–∞","–ö—Ä–∞—Å–Ω–æ–∞—Ä–º–µ–π—Å–∫–∞—è","–ö—Ä–∞—Å–Ω–∞—è","–Æ–∂–Ω–∞—è","–°–µ–≤–µ—Ä–Ω–∞—è","–ó–∞–ø–∞–¥–Ω–∞—è","–í–æ—Å—Ç–æ—á–Ω–∞—è","–ó–∞–≤–æ–¥—Å–∫–∞—è","–ö–æ–ª—Ö–æ–∑–Ω–∞—è","–°–ø–æ—Ä—Ç–∏–≤–Ω–∞—è","–ñ–µ–ª–µ–∑–Ω–æ–¥–æ—Ä–æ–∂–Ω–∞—è","–í–æ–∫–∑–∞–ª—å–Ω–∞—è","–ë–æ–ª—å–Ω–∏—á–Ω–∞—è","–ò–Ω—Ç–µ—Ä–Ω–∞—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è","–ü–∞—Ä—Ç–∏–∑–∞–Ω—Å–∫–∞—è","–ö–æ—Å–º–æ–Ω–∞–≤—Ç–æ–≤","–ú–∞—Ç—Ä–æ—Å–æ–≤–∞","–ß–∞–ø–∞–µ–≤–∞","–§—Ä—É–Ω–∑–µ","–ö–æ–æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–∞—è","–¢—Ä—É–¥–æ–≤–∞—è","–¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–∞—è","–û–∑—ë—Ä–Ω–∞—è","–ü—Ä–æ–º—ã—à–ª–µ–Ω–Ω–∞—è","–¢–∏—Ö–∞—è","–í–µ—Å–µ–Ω–Ω—è—è","–î—Ä—É–∂–±—ã","–Æ–±–∏–ª–µ–π–Ω–∞—è","–ë–µ—Ä–µ–∑–æ–≤–∞—è","–°–æ—Å–Ω–æ–≤–∞—è","–î—É–±–æ–≤–∞—è","–¶–≤–µ—Ç–æ—á–Ω–∞—è","–í–∏—à–Ω—ë–≤–∞—è","–ö–ª—É–±–Ω–∞—è","–ú–∏—á—É—Ä–∏–Ω–∞","–õ–æ–º–æ–Ω–æ—Å–æ–≤–∞","–ú–µ–Ω–¥–µ–ª–µ–µ–≤–∞","–ö–æ—Ä–æ–ª—ë–≤–∞","–¶–∏–æ–ª–∫–æ–≤—Å–∫–æ–≥–æ","–ù–∞—Ö–∏–º–æ–≤–∞","–£—à–∞–∫–æ–≤–∞"
]);

/* ===========================================================
   –ê–õ–ì–û–†–ò–¢–ú –õ–ï–í–ï–ù–®–¢–ï–ô–ù–ê –î–õ–Ø –ü–û–ò–°–ö–ê –ü–û–•–û–ñ–ò–• –°–õ–û–í
   =========================================================== */
function levenshtein(a, b) {
  const matrix = [];
  for (let i = 0; i <= b.length; i++) {
    matrix[i] = [i];
  }
  for (let j = 0; j <= a.length; j++) {
    matrix[0][j] = j;
  }
  for (let i = 1; i <= b.length; i++) {
    for (let j = 1; j <= a.length; j++) {
      if (b.charAt(i - 1) === a.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j] + 1
        );
      }
    }
  }
  return matrix[b.length][a.length];
}

// –ù–∞–π—Ç–∏ –±–ª–∏–∂–∞–π—à–µ–µ —Å–ª–æ–≤–æ –∏–∑ —Å–ª–æ–≤–∞—Ä—è (distance <= 2)
function findClosest(word, dictionary, maxDist = 2) {
  if (!word || word.length < 3) return null;
  const lower = word.toLowerCase();

  // –¢–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
  for (const entry of dictionary) {
    if (entry.toLowerCase() === lower) return null; // —É–∂–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ
  }

  let bestMatch = null;
  let bestDist = maxDist + 1;

  for (const entry of dictionary) {
    const dist = levenshtein(lower, entry.toLowerCase());
    if (dist > 0 && dist < bestDist) {
      bestDist = dist;
      bestMatch = entry;
    }
  }

  return bestDist <= maxDist ? bestMatch : null;
}

// –ö–æ—Ä—Ä–µ–∫—Ü–∏—è —Å–ª–æ–≤–∞ —á–µ—Ä–µ–∑ —Å–ª–æ–≤–∞—Ä–∏
function correctWord(word, type = "surname") {
  const dict = type === "surname" ? SURNAMES : type === "name" ? NAMES : STREETS;
  const corrected = findClosest(word, dict);
  return corrected || word;
}

/* ===========================================================
   UI –∏ –∑–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–æ–≤
   =========================================================== */
const EXT_OK = /\.(jpg|jpeg|png|webp|bmp|gif|tif|tiff|heic)$/i;
function isImageFile(f){
  return (f.type && f.type.startsWith("image/")) || EXT_OK.test(f.name);
}

const statusEl = document.getElementById("status");
const logEl = document.getElementById("log");
function setStatus(msg){ statusEl.textContent = msg || ""; }
function log(msg){
  const time = new Date().toLocaleTimeString();
  logEl.textContent += `[${time}] ${msg}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}
function prog(pct){ document.getElementById("progBar").style.width = Math.max(0, Math.min(100, pct)) + "%"; }

const fileInput = document.getElementById("fileInput");
const dirInput  = document.getElementById("dirInput");
const runBtn    = document.getElementById("runBtn");
const reparseBtn = document.getElementById("reparseBtn");
const cancelBtn = document.getElementById("cancelBtn");
const saveBtn   = document.getElementById("saveBtn");
const previewBody = document.querySelector("#preview tbody");
const countSpan = document.getElementById("countSpan");
const colSelect = document.getElementById("colSelect");
const COLS = ["–§–∞–π–ª","–§–ò–û","–¢–µ–ª–µ—Ñ–æ–Ω","–†–µ–≥–∏–æ–Ω","–ì–æ—Ä–æ–¥","–£–ª–∏—Ü–∞","–î–æ–º/–ö–≤","–ê–¥—Ä–µ—Å (–ø–æ–ª–Ω—ã–π)","Raw OCR"];
const clearColBtn = document.getElementById("clearColBtn");
const fillDownBtn = document.getElementById("fillDownBtn");
const concurrencySel = document.getElementById("concurrency");
const sidePanel = document.getElementById("sidePanel");
const previewImg = document.getElementById("previewImg");
const previewData = document.getElementById("previewData");

let filesList = [];
let rows = [];
let processedBlobs = new Map(); // filename -> blob URL –¥–ª—è –ø—Ä–µ–≤—å—é

const savedConc = localStorage.getItem("ocrConcurrency");
if(savedConc && (savedConc === "1" || savedConc === "2")){
  concurrencySel.value = savedConc;
}
concurrencySel.addEventListener("change", ()=> {
  localStorage.setItem("ocrConcurrency", concurrencySel.value);
});

function setFiles(list){
  const arr = Array.from(list || []);
  filesList = arr.filter(isImageFile);
  countSpan.textContent = filesList.length ? `–í—ã–±—Ä–∞–Ω–æ —Ñ–∞–π–ª–æ–≤: ${filesList.length}` : "–§–∞–π–ª—ã –Ω–µ –≤—ã–±—Ä–∞–Ω—ã";
  setStatus(filesList.length ? "–ì–æ—Ç–æ–≤–æ –∫ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—é" : "");
  runBtn.disabled = filesList.length === 0;
  reparseBtn.disabled = true;
  saveBtn.disabled = true;
  rows = [];
  previewBody.innerHTML = "";
  processedBlobs.clear();
  sidePanel.classList.add("hidden");
  prog(0);
  log(`–ü—Ä–∏–Ω—è—Ç–æ —Ñ–∞–π–ª–æ–≤: ${filesList.length}`);
}

fileInput.addEventListener("change", e => setFiles(e.target.files));
dirInput .addEventListener("change", e => setFiles(e.target.files));

const dropZone = document.getElementById("dropZone");
dropZone.addEventListener("dragover", e => { e.preventDefault(); dropZone.classList.add("dragover"); });
dropZone.addEventListener("dragleave", () => dropZone.classList.remove("dragover"));
dropZone.addEventListener("drop", e => { e.preventDefault(); dropZone.classList.remove("dragover"); setFiles(e.dataTransfer.files); });

/* ===========================================================
   –ê–í–¢–û–û–ü–†–ï–î–ï–õ–ï–ù–ò–ï –û–†–ò–ï–ù–¢–ê–¶–ò–ò
   –ü—Ä–æ—Å—Ç–∞—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∞: —Å—á–∏—Ç–∞–µ–º —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —á–µ—Ä–Ω—ã—Ö –ø–∏–∫—Å–µ–ª–µ–π –ø–æ –∫—Ä–∞—è–º
   –ï—Å–ª–∏ —Ç–µ–∫—Å—Ç –∏–¥–µ—Ç –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ - –Ω—É–∂–µ–Ω –ø–æ–≤–æ—Ä–æ—Ç
   =========================================================== */
function detectOrientation(imgData) {
  const {data, width, height} = imgData;

  // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —á–µ—Ä–Ω—ã—Ö –ø–∏–∫—Å–µ–ª–µ–π –≤ —Ä–∞–∑–Ω—ã—Ö –∑–æ–Ω–∞—Ö
  let topBlack = 0, bottomBlack = 0, leftBlack = 0, rightBlack = 0;
  const margin = Math.min(width, height) * 0.1;

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      const brightness = (data[idx] + data[idx+1] + data[idx+2]) / 3;
      const isBlack = brightness < 128;

      if (!isBlack) continue;

      if (y < margin) topBlack++;
      if (y > height - margin) bottomBlack++;
      if (x < margin) leftBlack++;
      if (x > width - margin) rightBlack++;
    }
  }

  // –ï—Å–ª–∏ —Ç–µ–∫—Å—Ç –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π - –±–æ–ª—å—à–µ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –ø–æ –±–æ–∫–∞–º
  // –ï—Å–ª–∏ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π - –±–æ–ª—å—à–µ —Å–≤–µ—Ä—Ö—É/—Å–Ω–∏–∑—É
  const horizontal = leftBlack + rightBlack;
  const vertical = topBlack + bottomBlack;

  // –ï—Å–ª–∏ —à–∏—Ä–∏–Ω–∞ –Ω–∞–º–Ω–æ–≥–æ –º–µ–Ω—å—à–µ –≤—ã—Å–æ—Ç—ã –∏ –º–Ω–æ–≥–æ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –ø–æ –±–æ–∫–∞–º - –≤–æ–∑–º–æ–∂–Ω–æ –ø–æ–≤–æ—Ä–æ—Ç –Ω–∞ 90
  if (width < height * 0.7 && horizontal > vertical * 1.5) {
    return 90; // –ø–æ–≤–æ—Ä–æ—Ç –Ω—É–∂–µ–Ω
  }

  return 0; // –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è –ø—Ä–∞–≤–∏–ª—å–Ω–∞—è
}

/* ===========================================================
   –ü—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
   =========================================================== */
async function fileToImageBitmap(file){
  const blobURL = URL.createObjectURL(file);
  const img = await createImageBitmap(await (await fetch(blobURL)).blob());
  URL.revokeObjectURL(blobURL);
  return img;
}

function getExifOrientation(buf){
  try{
    const view = new DataView(buf);
    if(view.getUint16(0,false) !== 0xFFD8) return 1;
    let offset = 2;
    while(offset < view.byteLength){
      const marker = view.getUint16(offset, false); offset += 2;
      if(marker === 0xFFE1){
        offset += 2;
        if(view.getUint32(offset, false) !== 0x45786966) return 1;
        offset += 6;
        const little = view.getUint16(offset, false) === 0x4949; offset += 2;
        if(view.getUint16(offset, little) !== 0x002A) return 1; offset += 2;
        let dirOffset = view.getUint32(offset, little); offset = offset - 4 + dirOffset;
        const numTags = view.getUint16(offset, little); offset += 2;
        for(let i=0;i<numTags;i++){
          const tag = view.getUint16(offset + i*12, little);
          if(tag === 0x0112){
            const val = view.getUint16(offset + i*12 + 8, little);
            return val || 1;
          }
        }
        return 1;
      } else {
        const len = view.getUint16(offset, false); offset += len;
      }
    }
  }catch(e){}
  return 1;
}

function drawWithOrientation(ctx, img, w, h, orientation){
  switch(orientation){
    case 2: ctx.translate(w,0); ctx.scale(-1,1); break;
    case 3: ctx.translate(w,h); ctx.rotate(Math.PI); break;
    case 4: ctx.translate(0,h); ctx.scale(1,-1); break;
    case 5: ctx.rotate(0.5*Math.PI); ctx.scale(1,-1); break;
    case 6: ctx.rotate(0.5*Math.PI); ctx.translate(0,-h); break;
    case 7: ctx.rotate(0.5*Math.PI); ctx.translate(w,-h); ctx.scale(-1,1); break;
    case 8: ctx.rotate(-0.5*Math.PI); ctx.translate(-w,0); break;
    default: break;
  }
  ctx.drawImage(img,0,0,w,h);
}

async function preprocessToBlob(file){
  const arrayBuffer = await file.arrayBuffer();
  const orientation = getExifOrientation(arrayBuffer) || 1;

  const img = await fileToImageBitmap(new File([arrayBuffer], file.name, {type:file.type}));
  const targetW = Math.min(2200, Math.max(1200, 1800));
  const scale = targetW / img.width;
  const W = Math.round(img.width * scale);
  const H = Math.round(img.height * scale);

  const rot90 = [5,6,7,8].includes(orientation);
  const cw = rot90 ? H : W;
  const ch = rot90 ? W : H;

  const cvs = new OffscreenCanvas(cw, ch);
  const ctx = cvs.getContext("2d", { willReadFrequently:true });
  ctx.save();
  drawWithOrientation(ctx, img, W, H, orientation);
  ctx.restore();

  let imgData = ctx.getImageData(0,0,cw,ch);
  const d = imgData.data;
  const hist = new Uint32Array(256);
  for(let i=0;i<d.length;i+=4){
    const y = (0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2])|0;
    d[i]=d[i+1]=d[i+2]=y; d[i+3]=255; hist[y]++;
  }

  function percentile(p){
    const target = p * (cw*ch);
    let acc=0;
    for(let i=0;i<256;i++){ acc+=hist[i]; if(acc>=target) return i; }
    return p===0?0:255;
  }
  const lo = percentile(0.02), hi = percentile(0.98);
  const span = Math.max(1, hi-lo);
  for(let i=0;i<d.length;i+=4){
    let y=d[i]; y = ((y-lo)*255/span)|0; if(y<0)y=0; if(y>255)y=255;
    d[i]=d[i+1]=d[i+2]=y;
  }

  // –ê–≤—Ç–æ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ –ø–æ—Å–ª–µ –Ω–∞—á–∞–ª—å–Ω–æ–π –ø—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∏
  const autoRotate = detectOrientation(imgData);
  if (autoRotate === 90) {
    log(`${file.name}: –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è, –ø–æ–≤–æ—Ä–æ—Ç –Ω–∞ 90¬∞`);
    // –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –Ω–∞ 90 –≥—Ä–∞–¥—É—Å–æ–≤
    const rotCvs = new OffscreenCanvas(ch, cw);
    const rotCtx = rotCvs.getContext("2d");
    rotCtx.translate(ch/2, cw/2);
    rotCtx.rotate(Math.PI/2);
    rotCtx.drawImage(cvs, -cw/2, -ch/2);

    // –û–±–Ω–æ–≤–ª—è–µ–º imgData
    imgData = rotCtx.getImageData(0, 0, ch, cw);
    const newD = imgData.data;
    for(let i=0;i<newD.length;i++) d[i] = newD[i];
  }

  // Otsu threshold
  const hist2 = new Uint32Array(256);
  for(let i=0;i<d.length;i+=4){ hist2[d[i]]++; }
  let sum=0, sumB=0, wB=0, wF=0, mB=0, mF=0, maxVar=0, thr=127;
  for(let i=0;i<256;i++) sum+= i*hist2[i];
  const total = cw*ch;
  for(let t=0;t<256;t++){
    wB += hist2[t]; if(wB===0) continue;
    wF = total - wB; if(wF===0) break;
    sumB += t*hist2[t];
    mB = sumB / wB; mF = (sum - sumB) / wF;
    const between = wB*wF*(mB-mF)*(mB-mF);
    if(between>maxVar){ maxVar=between; thr=t; }
  }
  for(let i=0;i<d.length;i+=4){
    const val = d[i] > thr ? 255 : 0;
    d[i]=d[i+1]=d[i+2]=val;
  }

  // morphology close
  const copy = new Uint8ClampedArray(d);
  const w = cw, h = ch;
  function idx(x,y){ return 4*(y*w + x); }
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      let maxv=0;
      for(let yy=-1;yy<=1;yy++)
        for(let xx=-1;xx<=1;xx++)
          maxv = Math.max(maxv, copy[idx(x+xx,y+yy)]);
      const i=idx(x,y); d[i]=d[i+1]=d[i+2]=maxv;
    }
  }
  const copy2 = new Uint8ClampedArray(d);
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      let minv=255;
      for(let yy=-1;yy<=1;yy++)
        for(let xx=-1;xx<=1;xx++)
          minv = Math.min(minv, copy2[idx(x+xx,y+yy)]);
      const i=idx(x,y); d[i]=d[i+1]=d[i+2]=minv;
    }
  }

  ctx.putImageData(imgData,0,0);
  const blob = await cvs.convertToBlob({ type:"image/png", quality:1 });
  return blob;
}

/* ===========================================================
   –£–ú–ù–´–ô –ü–ê–†–°–ï–† –ê–î–†–ï–°–ê –° –ö–û–ú–ü–û–ù–ï–ù–¢–ê–ú–ò
   =========================================================== */
const PHONE_RE_ANY_G = /(\+7|8)\s*\(?\s*\d{3}\s*\)?\s*[-\s]?\d{3}[-\s]?\d{2}[-\s]?\d{2}/g;
const ONLY_DIGITS = /\d/g;

function cleanNoise(text){
  return (text||"")
    .replace(/[‚Ä¢‚óè‚ó¶‚àô¬∑]/g," ")
    .replace(/[¬©¬Æ‚Ñ¢]/g," ")
    .replace(/—Ñ–∏–æ[:\s]*/gi," ")
    .replace(/—Ñ–∏–∑–ª–∏—Ü–æ/gi," ")
    .replace(/mobile/gi," ")
    .replace(/[‚Äî‚Äì]+/g,"-")
    .replace(/[\u200E\u200F\u00A0]/g," ")
    .replace(/\s{2,}/g," ")
    .trim();
}

function normalizePhone(raw){
  const digits = raw.match(ONLY_DIGITS)?.join("") || "";
  if(digits.length<10) return raw.trim();
  let d = digits;
  if(d.length===11 && d[0]==="8") d = "7"+d.slice(1);
  if(d.length!==11) return raw.trim();
  return "+7 " + d.slice(1,4) + " " + d.slice(4,7) + "-" + d.slice(7,9) + "-" + d.slice(9,11);
}

function parsePhones(text){
  const seen = new Set();
  const list = [];
  for(const m of (text||"").matchAll(PHONE_RE_ANY_G)){
    const ph = normalizePhone(m[0]);
    const key = ph.replace(/\D/g,"");
    if(!seen.has(key)){ seen.add(key); list.push(ph); }
  }
  return list.join(", ");
}

function toCyrLookalikes(s){
  const map = {
    A:"–ê", B:"–í", C:"–°", E:"–ï", H:"–ù", K:"–ö", M:"–ú", O:"–û", P:"–†", T:"–¢", X:"–•", Y:"–£",
    a:"–∞", b:"–≤", c:"—Å", e:"–µ", h:"–Ω", k:"–∫", m:"–º", o:"–æ", p:"—Ä", t:"—Ç", x:"—Ö", y:"—É"
  };
  return s.replace(/[ABCEHKMOPTXYabcehkmoptxy]/g, ch => map[ch] || ch);
}

function fixCyrConfusions(word){
  let w = toCyrLookalikes(word);
  w = w.replace(/–®—â|–®–©/g, "–©").replace(/—à—â|—à–©/g, "—â");
  w = w.replace(/–ô–ò/gu, "–ò").replace(/–π–∏/gu, "–∏");
  w = w.replace(/–ó3/g, "–ó").replace(/–∑3/g, "–∑");
  w = w.replace(/^[\.\-]+|[\.\-]+$/g, "");
  return w;
}

function titlecaseRu(s){
  return s.trim().split(/\s+/).map(p=>p? p[0].toUpperCase()+p.slice(1).toLowerCase():p).join(" ");
}

// –ü–∞—Ä—Å–∏–Ω–≥ –§–ò–û —Å ML-–∫–æ—Ä—Ä–µ–∫—Ü–∏–µ–π
function parseFio(text){
  const t = cleanNoise(text);
  const tokens = t.split(/[^–ê-–Ø–∞-—è–Å—ë-]+/)
    .map(w => w && fixCyrConfusions(w))
    .filter(w => w && w.length >= 2);

  const stop = /^(—Ä–æ—Å—Å–∏—è|–≥–æ—Ä–æ–¥|—É–ª–∏—Ü–∞|—É–ª|–æ–±–ª–∞—Å—Ç—å|–∫—Ä–∞–π|—Ä–∞–π–æ–Ω|—Ä—Ñ|—Ä–µ–≥–∏–æ–Ω)$/i;

  for(let i=0;i<tokens.length-1;i++){
    const a=tokens[i], b=tokens[i+1], c=tokens[i+2];
    if(stop.test(a)) continue;

    // –ü—Ä–æ–±—É–µ–º –∫–æ—Ä—Ä–µ–∫—Ü–∏—é
    const aCorrected = correctWord(a, "surname");
    const bCorrected = correctWord(b, "name");
    const cCorrected = c ? correctWord(c, "name") : null;

    if(c && a.length>=3 && b.length>=3 && c.length>=3) {
      const result = titlecaseRu(`${aCorrected} ${bCorrected} ${cCorrected}`);
      if (aCorrected !== a || bCorrected !== b || cCorrected !== c) {
        log(`‚ú® –ö–æ—Ä—Ä–µ–∫—Ü–∏—è –§–ò–û: "${a} ${b} ${c}" -> "${result}"`);
      }
      return result;
    }
    if(a.length>=3 && b.length>=3) {
      const result = titlecaseRu(`${aCorrected} ${bCorrected}`);
      if (aCorrected !== a || bCorrected !== b) {
        log(`‚ú® –ö–æ—Ä—Ä–µ–∫—Ü–∏—è –§–ò–û: "${a} ${b}" -> "${result}"`);
      }
      return result;
    }
  }
  return "";
}

function isPhoneish(ln){
  const digits = (ln||"").replace(/\D/g,"");
  return /\+/.test(ln) || digits.length >= 10;
}

// –£–º–Ω—ã–π –ø–∞—Ä—Å–µ—Ä –∞–¥—Ä–µ—Å–∞: –∏–∑–≤–ª–µ–∫–∞–µ—Ç –†–µ–≥–∏–æ–Ω, –ì–æ—Ä–æ–¥, –£–ª–∏—Ü—É, –î–æ–º/–ö–≤
function parseAddressComponents(text) {
  const result = {
    region: "",
    city: "",
    street: "",
    building: "",
    fullAddress: ""
  };

  const t = (text || "").replace(/\r/g, "");
  const start = t.search(/–†–æ—Å—Å–∏—è|–†–§/i);

  if (start < 0) {
    return result;
  }

  let tail = t.slice(start);
  tail = tail.replace(/^–†–§/i, "–†–æ—Å—Å–∏—è");

  let parts = tail.split(/\n/).map(s => s.trim()).filter(Boolean);
  const limited = [];
  for(let i=0; i<parts.length && i<6; i++){
    const ln = parts[i];
    if(isPhoneish(ln)) continue;
    if(/—Ñ–∏–æ|mobile|–º–æ–±–∏–ª|–∑–∞–∫–∞–∑|—Ç–µ–ª–µ—Ñ|–∫–ª–∏–µ–Ω—Ç|–ø–æ–ª—É—á–∞—Ç–µ–ª/iu.test(ln)) continue;
    limited.push(ln);
  }

  result.fullAddress = limited.join(", ")
    .replace(/^–†–æ—Å—Å–∏—è(?!\s*,)/i, "–†–æ—Å—Å–∏—è,")
    .replace(/\s*,\s*,/g, ", ")
    .replace(/\s{2,}/g, " ")
    .replace(/,\s*$/,"")
    .trim();

  // –ü–∞—Ä—Å–∏–Ω–≥ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
  const firstLine = limited[0] || "";

  // –†–µ–≥–∏–æ–Ω: –∏—â–µ–º "–æ–±–ª–∞—Å—Ç—å", "–∫—Ä–∞–π", "—Ä–µ—Å–ø—É–±–ª–∏–∫–∞", "–æ–±–ª.", "—Ä–µ—Å–ø."
  const regionMatch = firstLine.match(/,\s*([^,]+?(?:–æ–±–ª–∞—Å—Ç—å|–æ–±–ª\.?|–∫—Ä–∞–π|—Ä–µ—Å–ø—É–±–ª–∏–∫–∞|—Ä–µ—Å–ø\.?))/i);
  if (regionMatch) {
    result.region = regionMatch[1].trim()
      .replace(/\s+(–æ–±–ª–∞—Å—Ç—å|–æ–±–ª\.?|–∫—Ä–∞–π|—Ä–µ—Å–ø—É–±–ª–∏–∫–∞|—Ä–µ—Å–ø\.?)$/i, " $1")
      .trim();
  }

  // –ì–æ—Ä–æ–¥: –ø–æ—Å–ª–µ —Ä–µ–≥–∏–æ–Ω–∞ –∏–ª–∏ "–≥.", "–≥–æ—Ä–æ–¥"
  const cityMatch = firstLine.match(/,\s*(?:–≥\.?\s+)?([–ê-–Ø–Å][–∞-—è—ë\-\s]+?)(?=\s*,|$)/i);
  if (cityMatch) {
    let cityCandidate = cityMatch[1].trim();
    // –ï—Å–ª–∏ —ç—Ç–æ –Ω–µ —Ä–µ–≥–∏–æ–Ω - –±–µ—Ä—ë–º –∫–∞–∫ –≥–æ—Ä–æ–¥
    if (!/–æ–±–ª–∞—Å—Ç—å|–æ–±–ª\.|–∫—Ä–∞–π|—Ä–µ—Å–ø—É–±–ª–∏–∫–∞|—Ä–µ—Å–ø\./i.test(cityCandidate)) {
      result.city = cityCandidate.replace(/^–≥\.?\s*/i, "");
    }
  }

  // –£–ª–∏—Ü–∞: –∏—â–µ–º "—É–ª.", "—É–ª–∏—Ü–∞", "–ø—Ä–æ—Å–ø.", –∏ —Ç.–¥.
  const streetLine = limited.find(ln => /(?:—É–ª\.?|—É–ª–∏—Ü–∞|–ø—Ä–æ—Å–ø\.?|–ø—Ä–æ—Å–ø–µ–∫—Ç|–ø–µ—Ä\.?|–ø–µ—Ä–µ—É–ª–æ–∫|—à–æ—Å—Å–µ|—à\.|–±-—Ä|–±—É–ª—å–≤–∞—Ä|—Ç—Ä–∞–∫—Ç|–º–∫—Ä\.?|–∫–≤–∞—Ä—Ç–∞–ª|–ø—Ä–æ–µ–∑–¥)/i.test(ln));
  if (streetLine) {
    const streetMatch = streetLine.match(/((?:—É–ª\.?|—É–ª–∏—Ü–∞|–ø—Ä–æ—Å–ø\.?|–ø—Ä–æ—Å–ø–µ–∫—Ç|–ø–µ—Ä\.?|–ø–µ—Ä–µ—É–ª–æ–∫|—à–æ—Å—Å–µ|—à\.|–±-—Ä|–±—É–ª—å–≤–∞—Ä|—Ç—Ä–∞–∫—Ç|–º–∫—Ä\.?|–∫–≤–∞—Ä—Ç–∞–ª|–ø—Ä–æ–µ–∑–¥)\s+[^,\d]+)/i);
    if (streetMatch) {
      let streetName = streetMatch[1].trim()
        .replace(/^(—É–ª\.?|—É–ª–∏—Ü–∞|–ø—Ä–æ—Å–ø\.?|–ø—Ä–æ—Å–ø–µ–∫—Ç|–ø–µ—Ä\.?|–ø–µ—Ä–µ—É–ª–æ–∫)\s+/i, "");

      // –ö–æ—Ä—Ä–µ–∫—Ü–∏—è –Ω–∞–∑–≤–∞–Ω–∏—è —É–ª–∏—Ü—ã —á–µ—Ä–µ–∑ —Å–ª–æ–≤–∞—Ä—å
      const corrected = correctWord(streetName, "street");
      if (corrected !== streetName) {
        log(`‚ú® –ö–æ—Ä—Ä–µ–∫—Ü–∏—è —É–ª–∏—Ü—ã: "${streetName}" -> "${corrected}"`);
        streetName = corrected;
      }

      result.street = streetName;
    }

    // –î–æ–º/–∫–≤: –∏—â–µ–º "–¥.", "–¥–æ–º", "–∫–≤.", "–∫–≤–∞—Ä—Ç–∏—Ä–∞"
    const buildingMatch = streetLine.match(/(?:–¥\.?|–¥–æ–º)\s*(\d+[–∞-—è–ê-–Ø]?)(?:[,\s]+(?:–∫–≤\.?|–∫–≤–∞—Ä—Ç–∏—Ä–∞)\s*(\d+))?/i);
    if (buildingMatch) {
      const house = buildingMatch[1];
      const apt = buildingMatch[2];
      result.building = apt ? `–¥.${house}, –∫–≤.${apt}` : `–¥.${house}`;
    }
  }

  return result;
}

function parseOrder(raw, filename){
  const cleaned = cleanNoise(raw);
  const phone = parsePhones(cleaned);
  const fio = parseFio(cleaned);
  const addr = parseAddressComponents(cleaned);

  return {
    "–§–∞–π–ª": filename,
    "–§–ò–û": fio,
    "–¢–µ–ª–µ—Ñ–æ–Ω": phone,
    "–†–µ–≥–∏–æ–Ω": addr.region,
    "–ì–æ—Ä–æ–¥": addr.city,
    "–£–ª–∏—Ü–∞": addr.street,
    "–î–æ–º/–ö–≤": addr.building,
    "–ê–¥—Ä–µ—Å (–ø–æ–ª–Ω—ã–π)": addr.fullAddress || "",
    "Raw OCR": raw.trim()
  };
}

function validateRow(row){
  const warnings = [];

  if(row["–§–ò–û"] && (row["–§–ò–û"].length < 2 || row["–§–ò–û"].length > 60)){
    warnings.push("–§–ò–û: –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞");
  }

  if(row["–¢–µ–ª–µ—Ñ–æ–Ω"] && !row["–¢–µ–ª–µ—Ñ–æ–Ω"].startsWith("+7")){
    warnings.push("–¢–µ–ª–µ—Ñ–æ–Ω: –Ω–µ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å +7");
  }

  if(row["–ê–¥—Ä–µ—Å (–ø–æ–ª–Ω—ã–π)"] && !row["–ê–¥—Ä–µ—Å (–ø–æ–ª–Ω—ã–π)"].match(/–†–æ—Å—Å–∏—è/i)){
    warnings.push("–ê–¥—Ä–µ—Å: –Ω–µ—Ç '–†–æ—Å—Å–∏—è'");
  }

  if(!row["–§–ò–û"] && !row["–¢–µ–ª–µ—Ñ–æ–Ω"] && !row["–ê–¥—Ä–µ—Å (–ø–æ–ª–Ω—ã–π)"]){
    warnings.push("–ü—É—Å—Ç–æ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø–∞—Ä—Å–∏–Ω–≥–∞");
  }

  return warnings;
}

/* ===========================================================
   –ò–ù–¢–ï–†–ê–ö–¢–ò–í–ù–´–ô –ü–†–û–°–ú–û–¢–† –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ô
   =========================================================== */
function showPreview(rowIndex) {
  const row = rows[rowIndex];
  if (!row) return;

  const filename = row["–§–∞–π–ª"];
  const blobURL = processedBlobs.get(filename);

  if (!blobURL) {
    sidePanel.classList.add("hidden");
    return;
  }

  sidePanel.classList.remove("hidden");
  previewImg.src = blobURL;

  previewData.innerHTML = `
    <dt>–§–∞–π–ª:</dt><dd>${filename}</dd>
    <dt>–§–ò–û:</dt><dd>${row["–§–ò–û"] || "<–ø—É—Å—Ç–æ>"}</dd>
    <dt>–¢–µ–ª–µ—Ñ–æ–Ω:</dt><dd>${row["–¢–µ–ª–µ—Ñ–æ–Ω"] || "<–ø—É—Å—Ç–æ>"}</dd>
    <dt>–†–µ–≥–∏–æ–Ω:</dt><dd>${row["–†–µ–≥–∏–æ–Ω"] || "<–ø—É—Å—Ç–æ>"}</dd>
    <dt>–ì–æ—Ä–æ–¥:</dt><dd>${row["–ì–æ—Ä–æ–¥"] || "<–ø—É—Å—Ç–æ>"}</dd>
    <dt>–£–ª–∏—Ü–∞:</dt><dd>${row["–£–ª–∏—Ü–∞"] || "<–ø—É—Å—Ç–æ>"}</dd>
    <dt>–î–æ–º/–ö–≤:</dt><dd>${row["–î–æ–º/–ö–≤"] || "<–ø—É—Å—Ç–æ>"}</dd>
    <dt>Raw OCR:</dt><dd style="font-size:11px; max-height:100px; overflow:auto;">${row["Raw OCR"]?.substring(0, 300) || "<–ø—É—Å—Ç–æ>"}</dd>
  `;

  // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
  document.querySelectorAll("#preview tbody tr").forEach((tr, idx) => {
    tr.classList.toggle("selected", idx === rowIndex);
  });
}

/* ===========================================================
   –¢–∞–±–ª–∏—Ü–∞: –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä, —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
   =========================================================== */
function appendPreviewRow(r, warnings){
  const tr=document.createElement("tr");
  COLS.forEach((k,idx)=>{
    const td=document.createElement("td");
    td.textContent = r[k] ?? "";
    if(idx!==0){ td.setAttribute("contenteditable","true"); }
    td.addEventListener("dblclick", ()=> td.focus());
    tr.appendChild(td);
  });

  if(warnings && warnings.length > 0){
    tr.style.backgroundColor = "#fff3cd";
    tr.title = warnings.join("; ");
  }

  const rowIndex = previewBody.children.length;
  tr.addEventListener("click", (e) => {
    if (e.target.tagName !== "TD" || !e.target.hasAttribute("contenteditable")) {
      showPreview(rowIndex);
    }
  });

  previewBody.appendChild(tr);
}

function syncRowsFromTable(){
  rows = Array.from(previewBody.querySelectorAll("tr")).map(tr=>{
    const tds = tr.querySelectorAll("td");
    const obj = {};
    COLS.forEach((k,i)=> obj[k] = (tds[i]?.textContent || "").trim());
    return obj;
  });
}

clearColBtn.addEventListener("click", ()=>{
  const idx = colSelect.selectedIndex;
  if(idx===0){ alert("–°—Ç–æ–ª–±–µ—Ü –§–∞–π–ª –æ—á–∏—â–∞—Ç—å –Ω–µ–ª—å–∑—è."); return; }
  for(const tr of previewBody.querySelectorAll("tr")){
    const td = tr.children[idx];
    td.textContent = "";
  }
  syncRowsFromTable();
});

fillDownBtn.addEventListener("click", ()=>{
  const idx = colSelect.selectedIndex;
  if(idx===0){ alert("–°—Ç–æ–ª–±–µ—Ü –§–∞–π–ª –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤–Ω–∏–∑ –Ω–µ –∏–º–µ–µ—Ç —Å–º—ã—Å–ª–∞."); return; }
  const trs = Array.from(previewBody.querySelectorAll("tr"));
  if(trs.length<2) return;
  const base = trs[0].children[idx].textContent;
  const val = base || prompt("–í–≤–µ–¥–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤–Ω–∏–∑:", "");
  if(val===null) return;
  for(let i=1;i<trs.length;i++){
    trs[i].children[idx].textContent = val;
  }
  syncRowsFromTable();
});

previewBody.addEventListener("input", ()=> syncRowsFromTable());

/* ===========================================================
   –ü–µ—Ä–µ–ø–∞—Ä—Å–∏–Ω–≥
   =========================================================== */
reparseBtn.addEventListener("click", ()=>{
  if(rows.length === 0) return;

  log("–ü–µ—Ä–µ–ø–∞—Ä—Å–∏–Ω–≥ –¥–∞–Ω–Ω—ã—Ö –∏–∑ Raw OCR...");
  setStatus("–ü–µ—Ä–µ–ø–∞—Ä—Å–∏–Ω–≥...");

  const newRows = rows.map(r => {
    const raw = r["Raw OCR"] || "";
    const filename = r["–§–∞–π–ª"] || "";
    return parseOrder(raw, filename);
  });

  rows = newRows;
  previewBody.innerHTML = "";

  newRows.forEach(r => {
    const warnings = validateRow(r);
    appendPreviewRow(r, warnings);
  });

  setStatus("–ü–µ—Ä–µ–ø–∞—Ä—Å–∏–Ω–≥ –∑–∞–≤–µ—Ä—à–µ–Ω");
  log(`–ü–µ—Ä–µ–ø–∞—Ä—Å–µ–Ω–æ —Å—Ç—Ä–æ–∫: ${rows.length}`);
});

/* ===========================================================
   OCR —Å –ª–∏–º–∏—Ç–æ–º –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ—Å—Ç–∏
   =========================================================== */
let cancelFlag = false;

async function createWorkerSafe(){
  setStatus("–ó–∞–≥—Ä—É–∂–∞—é —è–∑—ã–∫–∏ OCR...");
  log("–ó–∞–≥—Ä—É–∑–∫–∞ —è–∑—ã–∫–æ–≤ rus+eng...");
  const worker = await Tesseract.createWorker("rus+eng", 1, {
    langPath: "https://tessdata.projectnaptha.com/4.0.0"
  });
  return worker;
}

async function recognizeWithFallback(worker, blob){
  const base = await worker.recognize(blob, { tessedit_pageseg_mode:"6" });
  let text = base?.data?.text || "";

  if(!parsePhones(text)){
    try{
      const cfg = { tessedit_pageseg_mode:"6", tessedit_char_whitelist:"+() -0123456789" };
      const phonePass = await worker.recognize(blob, cfg);
      const p = parsePhones(phonePass?.data?.text || "");
      if(p) text = (text + "\n" + p).trim();
    }catch(e){ /* –Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–æ */ }
  }
  return text;
}

async function runOCR(){
  if(typeof Tesseract === "undefined" || !Tesseract.createWorker){
    alert("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–≤–∏–∂–æ–∫ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç –Ω–∞ –ø–µ—Ä–≤—ã–π –∑–∞–ø—É—Å–∫.");
    return;
  }
  if(!filesList.length){ alert("–î–æ–±–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."); return; }

  runBtn.disabled = true; reparseBtn.disabled = true; saveBtn.disabled = true; cancelBtn.disabled = false;
  rows = []; previewBody.innerHTML = ""; prog(1); setStatus("–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞..."); logEl.textContent = "";
  processedBlobs.clear();
  sidePanel.classList.add("hidden");

  cancelFlag = false;
  let processed = 0;
  const total = filesList.length;
  const conc = parseInt(concurrencySel.value,10) || 1;
  const startTime = Date.now();

  log(`‚ú® v2.0: —É–º–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥, ML-–∫–æ—Ä—Ä–µ–∫—Ü–∏—è, –∞–≤—Ç–æ-–æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è`);
  log(`–ù–∞—á–∞–ª–æ –æ–±—Ä–∞–±–æ—Ç–∫–∏: ${total} —Ñ–∞–π–ª–æ–≤, –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ—Å—Ç—å ${conc}`);

  const workers = [];
  try{
    const needWorkers = conc;
    for(let i=0;i<needWorkers;i++){ workers.push(await createWorkerSafe()); }
  }catch(e){
    alert("–Ø–∑—ã–∫–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª–∏—Å—å. –ù—É–∂–µ–Ω –¥–æ—Å—Ç—É–ø –∫ tessdata.projectnaptha.com –∏–ª–∏ VPN.");
    setStatus("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —è–∑—ã–∫–æ–≤");
    runBtn.disabled=false; cancelBtn.disabled=true;
    return;
  }

  const tasks = filesList.map((file, idx)=>({file, idx}));
  const results = new Array(tasks.length);

  async function processTask(worker, task){
    if(cancelFlag) return;
    const {file, idx} = task;
    try{
      setStatus(`–ü—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞: ${idx+1}/${total}`);
      const blob = await preprocessToBlob(file);

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º blob –¥–ª—è –ø—Ä–µ–≤—å—é
      const blobURL = URL.createObjectURL(blob);
      processedBlobs.set(file.name, blobURL);

      setStatus(`–†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ: ${idx+1}/${total}`);
      const txt = await recognizeWithFallback(worker, blob);

      const row = parseOrder(txt, file.name);
      const warnings = validateRow(row);

      results[idx] = row;
      appendPreviewRow(row, warnings);

      if(warnings.length > 0){
        log(`${file.name}: ${warnings.join(", ")}`);
      }
    }catch(err){
      results[idx] = {
        "–§–∞–π–ª": file.name,
        "–§–ò–û":"",
        "–¢–µ–ª–µ—Ñ–æ–Ω":"",
        "–†–µ–≥–∏–æ–Ω":"",
        "–ì–æ—Ä–æ–¥":"",
        "–£–ª–∏—Ü–∞":"",
        "–î–æ–º/–ö–≤":"",
        "–ê–¥—Ä–µ—Å (–ø–æ–ª–Ω—ã–π)":"",
        "Raw OCR":"–û—à–∏–±–∫–∞ OCR: " + (err.message || err)
      };
      log(`–û—à–∏–±–∫–∞ ${file.name}: ${err.message || err}`);
    }finally{
      processed++;
      prog(Math.round((processed/total)*100));

      const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
      const avgPerFile = (elapsed / processed).toFixed(1);
      setStatus(`–ì–æ—Ç–æ–≤–æ: ${processed}/${total} (avg ${avgPerFile}s/—Ñ–∞–π–ª)`);
    }
  }

  let cursor = 0;
  async function workerLoop(worker){
    while(!cancelFlag && cursor < tasks.length){
      const myTask = tasks[cursor++];
      await processTask(worker, myTask);
    }
  }

  await Promise.all(workers.map(w => workerLoop(w))).catch(()=>{});

  for(const w of workers){
    try{ await w.terminate(); }catch(e){}
  }

  if(cancelFlag){
    setStatus("–û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º");
    log("–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞. –ú–æ–∂–Ω–æ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å.");
    runBtn.disabled = false; cancelBtn.disabled = true;
    return;
  }

  rows = results.filter(Boolean);

  const totalTime = ((Date.now() - startTime) / 1000).toFixed(1);
  const avgTime = (totalTime / total).toFixed(1);

  setStatus(`–ì–æ—Ç–æ–≤–æ –∑–∞ ${totalTime}s`);
  log(`‚úÖ –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ: ${rows.length} —Ñ–∞–π–ª–æ–≤ –∑–∞ ${totalTime}s (—Å—Ä–µ–¥–Ω–µ–µ ${avgTime}s/—Ñ–∞–π–ª)`);

  saveBtn.disabled = rows.length === 0;
  reparseBtn.disabled = rows.length === 0;
  runBtn.disabled = false;
  cancelBtn.disabled = true;
}

cancelBtn.addEventListener("click", ()=>{ cancelFlag = true; cancelBtn.disabled = true; });

/* ===========================================================
   –≠–∫—Å–ø–æ—Ä—Ç –≤ Excel
   =========================================================== */
function saveExcel(){
  syncRowsFromTable();
  if(!rows.length){ alert("–ü–æ–∫–∞ –Ω–µ—á–µ–≥–æ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å."); return; }
  const header = COLS;
  const ws = XLSX.utils.json_to_sheet(rows, { header });
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, "Orders");

  const timestamp = new Date().toISOString().slice(0,19).replace(/:/g,"-");
  XLSX.writeFile(wb, `orders_ocr_v2_${timestamp}.xlsx`);

  log(`Excel —Å–æ—Ö—Ä–∞–Ω–µ–Ω: orders_ocr_v2_${timestamp}.xlsx`);
}

runBtn.addEventListener("click", runOCR);
saveBtn.addEventListener("click", saveExcel);

log("‚ú® OCR v2.0 –∑–∞–≥—Ä—É–∂–µ–Ω: —É–º–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥, ML-–∫–æ—Ä—Ä–µ–∫—Ü–∏—è, –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º");
log("–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª—ã –∏ –Ω–∞–∂–º–∏—Ç–µ '–†–∞—Å–ø–æ–∑–Ω–∞—Ç—å'");
</script>
</body>
</html>
